# ==============================================================================
# PROJETO 1 - ARQUITETURA E ORGANIZAÇÃO DE COMPUTADORES (UFRPE)
# Banco MIPS - Sistema Bancário
# Professor: Vitor Coutinho
# Alunos: Arthur Leonardo, Guilherme Guimarães, José Neto e Maria Eduarda
# ==============================================================================

.data
    # ==========================================================================
    # ÁREA DE DADOS
    # ==========================================================================

    # --- Configurações do Sistema ---
    MAX_CLIENTES:   .word 50        # Número máximo de clientes permitidos
    QTD_CLIENTES:   .word 0         # Contador atual de clientes cadastrados

    # --- Banco de Dados dos Clientes (Vetores Paralelos) ---
    # Usamos .align 2 para garantir que os endereços de memória sejam múltiplos de 4.
    # Isso é importante para evitar erros de barramento (bus error) em algumas arquiteturas MIPS.
    .align 2
    CLIENTES_CPF:   .space 600      # 12 bytes (11 dígitos + \0) * 50 clientes
    .align 2
    CLIENTES_CONTA: .space 350      # 7 bytes (6 dígitos + \0) * 50 clientes
    .align 2
    CLIENTES_NOME:  .space 2500     # 50 bytes * 50 clientes
    .align 2
    CLIENTES_SALDO: .word 0:50      # Vetor de inteiros. Inicia com 50 zeros (4 bytes cada).
    .align 2
    CLIENTES_LIMITE:.word 150000:50 # Limite inicial por cliente (R$1500,00)
    .align 2
    CLIENTES_FATURA: .word 0:50     # Fatura do cliente com o banco
    
    # --- Histórico de Transações  ---
    .align 2
    HISTORICO_DEBITO_VALOR: .word 0:2500   # Guarda até 50 valores de transação por cliente
    HISTORICO_DEBITO_QTD:   .word 0:50     # Contador de quantas transações cada cliente fez
    .align 2
    HISTORICO_CREDITO_VALOR: .word 0:2500  # Guarda até 50 valores de transação por cliente
    HISTORICO_CREDITO_QTD:   .word 0:50    # Contador de quantas transações cada cliente fez
    .align 2
    HISTORICO_CREDITO_TIPO: .word 0:2500   # Guarda o tipo de transação de crédito
    .align 2
    HISTORICO_DEBITO_TIPO:  .word 0:2500   # Guarda o tipo de transação de débito

    # --- Buffers de Processamento de Texto ---
    buffer_cmd:     .space 256      # Armazena a linha de comando completa digitada pelo usuário
    arg0:           .space 64       # Armazena o primeiro token (o comando em si)
    arg1:           .space 64       # Armazena o primeiro argumento (ex: CPF)
    arg2:           .space 64       # Armazena o segundo argumento (ex: Conta)
    arg3:           .space 64       # Armazena o terceiro argumento (ex: Nome)
    buffer_resp:        .space 4        # Pequeno buffer para ler a resposta (s/n) na exclusão do histórico

    # --- Mensagens para o Usuário ---
    str_banner:         .asciiz "\nSmartBank-shell>> "   # Prompt do terminal
    str_erro_cmd:       .asciiz "Comando invalido\n"
    str_sucesso_cad:    .asciiz "Cliente cadastrado com sucesso. Número da conta: "
    str_cheio:          .asciiz "Erro: Banco cheio.\n"
    str_hifen:          .asciiz "-"
    str_newline:        .asciiz "\n"
    str_virgula:        .asciiz ","
    str_erro_cliente:   .asciiz "Falha: cliente inexistente\n"
    str_deposito:       .asciiz "DEPOSITO:     +R$ "
    str_saque:          .asciiz "SAQUE:        -R$ "
    str_transf_rec:     .asciiz "TRANSF. RECEBIDA: +R$ "
    str_transf_env:     .asciiz "TRANSF. ENVIADA:  -R$ "
    str_extrato_header: .asciiz "\n--- Extrato de Debitos ---\n"
    str_ext_cred_header: .asciiz "\n--- Extrato de Credito ---\n"
    str_sem_transacoes: .asciiz "Nenhuma transacao encontrada.\n"
    str_sucesso_dep:    .asciiz "Deposito realizado. Novo saldo: R$ "
    str_sucesso_saque:  .asciiz "Saque realizado. Novo saldo: R$ "
    str_erro_saldo:     .asciiz "Falha: saldo insuficiente\n"
    str_sucesso_transf: .asciiz "Transferência realizada com sucesso.\n"
    str_erro_limite:    .asciiz "Falha: limite de credito insuficiente\n"
    str_sucesso_limite: .asciiz "Limite de credito alterado com sucesso para: R$ "
    str_sucesso_pagto:   .asciiz "Pagamento de fatura realizado: R$ "
    str_compra:          .asciiz "COMPRA: R$ "
    str_pagto:           .asciiz "PAGAMENTO:  R$ "
    str_confirma_fmt:   .asciiz "Tem certeza que deseja apagar o historico? (s/n): "
    str_sucesso_fmt:    .asciiz "Historico apagado com sucesso.\n"
    str_cancela_fmt:    .asciiz "Operacao cancelada.\n"
    str_sucesso_fechar: .asciiz "Conta fechada com sucesso.\n"
    str_erro_fechar:    .asciiz "Falha: conta ainda possui saldo de R$ "
    str_info_header:    .asciiz "\n--- Resumo da Conta ---\n"
    str_lbl_saldo:      .asciiz "Saldo em Conta: R$ "
    str_lbl_limite:     .asciiz "Limite Total:   R$ "
    str_lbl_fatura:     .asciiz "Fatura Atual:   R$ "
    str_lbl_disponivel: .asciiz "Disponivel Cred:R$ "
    str_sucesso_data:   .asciiz "Data e hora do sistema atualizadas.\n"
    str_data_atual:     .asciiz "Data/Hora atual: "
    str_barra:          .asciiz "/"
    str_dois_pontos:    .asciiz ":"
    str_espaco:         .asciiz " "
    str_juros:          .asciiz "JUROS:  R$ "
    
    # --- Comandos do Sistema ---
    # Estas strings são usadas para comparar com o que o usuário digitou.
    cmd_cadastrar:       .asciiz "conta_cadastrar"
    cmd_debito_extrato:  .asciiz "debito_extrato"
    cmd_credito_extrato: .asciiz "credito_extrato"
    cmd_depositar:       .asciiz "depositar"
    cmd_sacar:           .asciiz "sacar"
    cmd_transferir:      .asciiz "transferir_debito"
    cmd_transf_credito:  .asciiz "transferir_credito"
    cmd_pagar_fatura:    .asciiz "pagar_fatura"
    cmd_alterar_limite:  .asciiz "alterar_limite"
    cmd_conta_format:    .asciiz "conta_format"
    cmd_conta_fechar:    .asciiz "conta_fechar"
    cmd_conta_info:      .asciiz "conta_info"
    cmd_data_hora:       .asciiz "data_hora"
    cmd_ver_hora:        .asciiz "ver_hora"
    cmd_sair:            .asciiz "sair"
    
    # --- RELÓGIO DO SISTEMA ---
    # Inicializa com uma data padrão (ex: 01/01/2025 12:00:00)
    DATA_DIA:   .word 1         # Aloca 4 bytes na memória para guardar o Dia, com valor inicial 1
    DATA_MES:   .word 1         # Aloca 4 bytes na memória para guardar o Mês, com valor inicial 1
    DATA_ANO:   .word 2025      # Aloca 4 bytes na memória para guardar o Ano, com valor inicial 2025
    HORA_H:     .word 12        # Aloca 4 bytes na memória para guardar a Hora, com valor inicial 12
    HORA_M:     .word 0         # Aloca 4 bytes na memória para guardar o Minuto, com valor inicial 0
    HORA_S:     .word 0         # Aloca 4 bytes na memória para guardar o Segundo, com valor inicial 0
    
    # Guarda o tempo (em milissegundos) da última atualização
    LAST_TIME_CHECK: .word 0    # Aloca 4 bytes para guardar o último 'timestamp' do syscall 30
    
    # --- Variáveis para Cálculo de Juros ---
    # Guarda o valor do HORA_S da última vez que o juros foi calculado
    LAST_JUROS_TIME_MS: .word 0      # Guarda o tempo total em MS do último cálculo de juros
    
    # --- FORMATAR, SALVAR E RECARREGAR ---
    # 1. Formatar
    str_confirma_fmt_g: .asciiz "TEM CERTEZA QUE DESEJA APAGAR O BANCO INTEIRO? (s/n): "
    str_sucesso_fmt_g:  .asciiz "Banco de dados zerado com sucesso.\n"
    cmd_formatar:       .asciiz "formatar"
    
    # 2. Salvar
    str_sucesso_salvar: .asciiz "Dados salvos com sucesso em banco.dat\n"
    str_erro_salvar:    .asciiz "Falha ao abrir/salvar o arquivo.\n"
    cmd_salvar:         .asciiz "salvar"
    filename:           .asciiz "banco.dat"
    
    # 3. Recarregar
    str_sucesso_recar:  .asciiz "Dados recarregados com sucesso.\n"
    str_erro_recar:     .asciiz "Falha ao abrir/ler o arquivo.\n"
    cmd_recarregar:     .asciiz "recarregar"
    
.text
.globl main

# ==============================================================================
# MAIN SHELL LOOP
# ==============================================================================
main:
    # --- INICIALIZA O RELÓGIO E JUROS ---
    # Pega a hora atual do sistema (syscall 30)
    li $v0, 30                  # Carrega o código 30 (syscall: get_time) no registrador $v0
    syscall                     # Executa a chamada de sistema; $a0 recebe o tempo atual em ms
    # Salva como a "última vez checada" para evitar um pulo gigante no tempo
    sw $a0, LAST_TIME_CHECK     # Salva o tempo atual (de $a0) na variável de memória LAST_TIME_CHECK
    sw $a0, LAST_JUROS_TIME_MS  # Salva o tempo atual (de $a0) na variável de memória LAST_JUROS_TIME_MS
shell_loop:
    # ==================================================================
    # MOTOR DO RELÓGIO
    # ==================================================================
    li $v0, 30                  # Carrega o código 30 (syscall: get_time) no registrador $v0
    syscall                     # Executa a chamada de sistema; $a0 recebe o tempo atual
    move $t0, $a0               # $t0 = Hora Atual (new) -> Copia o tempo atual de $a0 para $t0
    lw $t1, LAST_TIME_CHECK     # $t1 = Hora Antiga (old) -> Carrega o tempo da última checagem de $t1
    sub $t2, $t0, $t1           # $t2 = Delta (milisegundos) -> Calcula a diferença (TempoAtual - TempoAntigo)
    
    # Se delta for 0 ou negativo (pouco provável), pula tudo
    ble $t2, $zero, clock_fim   # (Branch if Less/Equal) Se $t2 <= 0, pula para a etiqueta clock_fim

    li $t3, 1000                # Carrega o valor 1000 em $t3 (para dividir milissegundos)
    div $t2, $t3                # Divide o delta ($t2) por 1000 ($t3). (Quociente em LO, Resto em HI)
    mflo $t4                    # (Move From LO) Move o quociente (segundos) para $t4
                                # $t4 = Segundos que se passaram

    # Se 0 segundos se passaram, não faz nada
    beq $t4, $zero, clock_fim   # (Branch if Equal) Se $t4 == 0, pula para clock_fim

    # Salva a hora atual (new) como a "última checagem"
    sw $t0, LAST_TIME_CHECK     # Salva o tempo atual ($t0) na variável LAST_TIME_CHECK para o próximo loop

    # Carrega relógio atual do banco
    lw $t5, HORA_S              # Carrega o valor atual de Segundos da memória para $t5
    lw $t6, HORA_M              # Carrega o valor atual de Minutos da memória para $t6
    lw $t7, HORA_H              # Carrega o valor atual de Horas da memória para $t7
    lw $t8, DATA_DIA            # Carrega o valor atual de Dia da memória para $t8

    # Adiciona os segundos que passaram
    add $t5, $t5, $t4           # Soma os segundos atuais ($t5) com os segundos que se passaram ($t4)

    # --- Propagação de Tempo ---
clock_loop_s:
    # Enquanto Segundos >= 60...
    blt $t5, 60, clock_loop_m   # (Branch if Less Than) Se Segundos ($t5) < 60, pula para a checagem de minutos
    sub $t5, $t5, 60            # Tira 60 dos segundos -> Segundos = Segundos - 60
    add $t6, $t6, 1             # Adiciona 1 aos minutos -> Minutos = Minutos + 1
    j clock_loop_s              # (Jump) Volta ao início do loop de segundos para checar de novo

clock_loop_m:
    # Enquanto Minutos >= 60...
    blt $t6, 60, clock_loop_h   # (Branch if Less Than) Se Minutos ($t6) < 60, pula para a checagem de horas
    sub $t6, $t6, 60            # Tira 60 dos minutos -> Minutos = Minutos - 60
    add $t7, $t7, 1             # Adiciona 1 às horas -> Horas = Horas + 1
    j clock_loop_m              # (Jump) Volta ao início do loop de minutos para checar de novo

clock_loop_h:
    # Enquanto Horas >= 24...
    blt $t7, 24, clock_save     # (Branch if Less Than) Se Horas ($t7) < 24, pula para salvar
    sub $t7, $t7, 24            # Tira 24 das horas -> Horas = Horas - 24
    add $t8, $t8, 1             # Adiciona 1 ao dia -> Dia = Dia + 1
    j clock_loop_h              # (Jump) Volta ao início do loop de horas para checar de novo
    # (Não vamos propagar dias para meses por ser muito complexo)

clock_save:
    # Salva os novos valores
    sw $t5, HORA_S              # Salva o valor atualizado de Segundos ($t5) na memória
    sw $t6, HORA_M              # Salva o valor atualizado de Minutos ($t6) na memória
    sw $t7, HORA_H              # Salva o valor atualizado de Horas ($t7) na memória
    sw $t8, DATA_DIA            # Salva o valor atualizado de Dia ($t8) na memória

clock_fim:

    # GATILHO DE JUROS
    lw $t1, LAST_JUROS_TIME_MS  # $t1 = Hora do Último Juros (MS)
    sub $t2, $t0, $t1           # $t2 = Delta (MS)

    li $t3, 60000               # 60 segundos = 60000 milissegundos
    blt $t2, $t3, juros_skip    # Se o delta for MENOR que 60s, pula

    jal exec_calcula_juros      # Roda a função que aplica juros em todos
    sw $t0, LAST_JUROS_TIME_MS  # Atualiza a hora do último juros para AGORA

juros_skip:
    # ==================================================================
       
    li $v0, 4                   # Carrega o código 4 (syscall: print_string)
    la $a0, str_banner          # Carrega o endereço da string do banner em $a0
    syscall                     # Executa a chamada de sistema (imprime o banner)

    li $v0, 8                   # Carrega o código 8 (syscall: read_string)
    la $a0, buffer_cmd          # Carrega o endereço do buffer de destino em $a0
    li $a1, 256                 # Define o tamanho máximo (256 bytes) em $a1
    syscall                     # Executa a chamada de sistema (lê a entrada do usuário)

    la $a0, buffer_cmd          # Carrega o endereço da string digitada em $a0 (argumento)
    jal parser_comandos         # (Jump And Link) Chama a função que separa a string em arg0, arg1...

    # --- DISPATCHER DE COMANDOS ---
    # O código abaixo compara o comando (arg0) com uma lista de comandos conhecidos.
    # Se encontrar uma correspondência, ele pula (beq) para a função de execução correta.

    la $a0, arg0                # Carrega o comando digitado pelo usuário (argumento para strcmp)
    la $a1, cmd_cadastrar       # Carrega a string "conta_cadastrar" (argumento para strcmp)
    jal strcmp                  # Chama a função que compara as duas strings
    beq $v0, 0, exec_cadastrar  # (Branch if Equal) Se $v0 (retorno) for 0 (iguais), pula para exec_cadastrar

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_debito_extrato  # Carrega "debito_extrato"
    jal strcmp                  # Compara
    beq $v0, 0, exec_debito_extrato # Pula se for igual
    
    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_credito_extrato # Carrega "credito_extrato"
    jal strcmp                  # Compara
    beq $v0, 0, exec_credito_extrato # Pula se for igual
    
    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_depositar       # Carrega "depositar"
    jal strcmp                  # Compara
    beq $v0, 0, exec_depositar  # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_sacar           # Carrega "sacar"
    jal strcmp                  # Compara
    beq $v0, 0, exec_sacar      # Pula se for igual
    
    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_transferir      # Carrega "transferir_debito"
    jal strcmp                  # Compara
    beq $v0, 0, exec_transferir # Pula se for igual
    
    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_transf_credito  # Carrega "transferir_credito"
    jal strcmp                  # Compara
    beq $v0, 0, exec_transf_credito # Pula se for igual
    
    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_conta_info      # Carrega "conta_info"
    jal strcmp                  # Compara
    beq $v0, 0, exec_conta_info # Pula se for igual
    
    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_alterar_limite  # Carrega "alterar_limite"
    jal strcmp                  # Compara
    beq $v0, 0, exec_alterar_limite # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_pagar_fatura    # Carrega "pagar_fatura"
    jal strcmp                  # Compara
    beq $v0, 0, exec_pagar_fatura # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_conta_format    # Carrega "conta_format"
    jal strcmp                  # Compara
    beq $v0, 0, exec_conta_format # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_conta_fechar    # Carrega "conta_fechar"
    jal strcmp                  # Compara
    beq $v0, 0, exec_conta_fechar # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_data_hora       # Carrega "data_hora"
    jal strcmp                  # Compara
    beq $v0, 0, exec_data_hora  # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_ver_hora        # Carrega "ver_hora"
    jal strcmp                  # Compara
    beq $v0, 0, exec_ver_hora   # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_formatar        # Carrega "formatar"
    jal strcmp                  # Compara
    beq $v0, 0, exec_formatar   # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_salvar          # Carrega "salvar"
    jal strcmp                  # Compara
    beq $v0, 0, exec_salvar     # Pula se for igual
    
    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_recarregar      # Carrega "recarregar"
    jal strcmp                  # Compara
    beq $v0, 0, exec_recarregar # Pula se for igual

    la $a0, arg0                # Carrega o comando digitado
    la $a1, cmd_sair            # Carrega "sair"
    jal strcmp                  # Compara
    beq $v0, 0, fim_programa    # Pula se for igual

    # --- TRATAMENTO DE ERRO ---
    li $v0, 4                   # Carrega o código 4 (syscall: print_string)
    la $a0, str_erro_cmd        # Carrega o endereço da string "Comando invalido"
    syscall                     # Executa a chamada (imprime o erro)
    j shell_loop                # (Jump) Volta para o início do shell_loop
    
# ==============================================================================
# COMANDO: CADASTRAR
# Formato: conta_cadastrar-<CPF>-<conta>-<nome>
# Objetivo: Cadastrar um novo cliente
# ==============================================================================
exec_cadastrar:
    addi $sp, $sp, -8       # Aloca 8 bytes na pilha (para 2 registradores)
    sw $ra, 4($sp)          # Salva o registrador $ra (endereço de retorno) na pilha
    sw $s1, 0($sp)          # Salva o registrador $s1 (que será usado para o índice) na pilha

    lw $t0, QTD_CLIENTES    # Carrega a quantidade atual de clientes em $t0
    lw $t1, MAX_CLIENTES    # Carrega a quantidade máxima de clientes em $t1
    bge $t0, $t1, cad_erro_cheio # (Branch if Greater/Equal) Se qtd_atual >= max, pula para erro (banco cheio)

    # Calcula DV
    la $a0, arg2            # Carrega o endereço da string da conta (arg2) como argumento
    jal calcula_dv          # Chama a função que calcula o dígito verificador
    move $s0, $v0           # $s0 guarda o DV -> Move o resultado (DV) de $v0 para $s0

    # --- SALVANDO NA MEMÓRIA ---
    lw $s1, QTD_CLIENTES    # Carrega o índice do novo cliente (valor atual de QTD_CLIENTES) em $s1

    # 1. CPF
    la $a0, CLIENTES_CPF    # Carrega o endereço base do vetor de CPFs em $a0
    li $t2, 12              # Carrega o valor 12 (tamanho de cada CPF) em $t2
    mul $t1, $s1, $t2       # Calcula o offset: $t1 = índice ($s1) * 12 ($t2)
    addu $a0, $a0, $t1      # Calcula o endereço final: $a0 = Base + Offset (sem checagem de overflow)
    la $a1, arg1            # Carrega o endereço da string do CPF (arg1) como argumento
    jal strcpy              # Chama a função para copiar a string

    # 2. Conta
    la $a0, CLIENTES_CONTA  # Carrega o endereço base do vetor de Contas
    li $t2, 7               # Carrega o valor 7 (tamanho de cada conta)
    mul $t1, $s1, $t2       # Calcula o offset: $t1 = índice ($s1) * 7 ($t2)
    addu $a0, $a0, $t1      # Calcula o endereço final
    la $a1, arg2            # Carrega o endereço da string da Conta (arg2)
    jal strcpy              # Chama a função para copiar a string

    # 3. Nome
    la $a0, CLIENTES_NOME   # Carrega o endereço base do vetor de Nomes
    li $t2, 50              # Carrega o valor 50 (tamanho de cada nome)
    mul $t1, $s1, $t2       # Calcula o offset: $t1 = índice ($s1) * 50 ($t2)
    addu $a0, $a0, $t1      # Calcula o endereço final
    la $a1, arg3            # Carrega o endereço da string do Nome (arg3)
    jal strcpy              # Chama a função para copiar a string

    # Incrementa contador
    addi $s1, $s1, 1        # Incrementa o índice (que também é a quantidade)
    sw $s1, QTD_CLIENTES    # Salva o novo valor da quantidade de clientes na memória

    # Feedback
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_sucesso_cad # Carrega o endereço da mensagem de sucesso
    syscall                 # Imprime a mensagem

    la $a0, arg2            # Carrega o endereço da string da conta (arg2)
    syscall                 # Imprime o número da conta

    la $a0, str_hifen       # Carrega o endereço da string "-"
    syscall                 # Imprime o hífen
    
    li $t2, 10              # Carrega o valor 10 em $t2 (para comparar com o DV)
    beq $s0, $t2, cad_print_x # (Branch if Equal) Se DV ($s0) == 10, pula para imprimir 'X'
    move $a0, $s0           # Move o DV ($s0) para $a0 (argumento para syscall)
    li $v0, 1               # Carrega o código 1 (syscall: print_int)
    syscall                 # Imprime o DV (número)
    j cad_fim               # (Jump) Pula para o final da função

cad_print_x:
    li $a0, 'X'             # Carrega o caractere 'X' em $a0
    li $v0, 11              # Carrega o código 11 (syscall: print_char)
    syscall                 # Imprime 'X'

cad_fim:
    lw $s1, 0($sp)          # Restaura $s1 original -> Carrega o valor da pilha de volta para $s1
    lw $ra, 4($sp)          # Restaura $ra -> Carrega o valor da pilha de volta para $ra
    addi $sp, $sp, 8        # Libera os 8 bytes alocados na pilha
    j shell_loop            # (Jump) Volta para o loop principal do shell

cad_erro_cheio:
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_cheio       # Carrega o endereço da mensagem "Banco cheio"
    syscall                 # Imprime a mensagem
    j cad_fim               # (Jump) Pula para o final da função (para restaurar a pilha e voltar ao shell)
    
    # ==============================================================================
# COMANDO: DEPOSITAR
# Formato: depositar-<Conta>-<Valor(centavos)>
# Objetivo: Depositar determinado valor em uma conta
# ==============================================================================
exec_depositar:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # 1. Busca o cliente pela conta (arg1)
    la $a0, arg1            # Carrega o endereço da string da conta (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $t0, $v0           # $t0 = índice do cliente -> Move o resultado (índice ou -1) de $v0
    li $t1, -1              # Carrega -1 para comparar
    beq $t0, $t1, dep_erro_cli # Se $t0 == -1 (não achou), pula para o erro

    # 2. Converte o valor do depósito (arg2) para inteiro
    move $s0, $t0           # Salva índice do cliente em $s0 (registrador seguro)
    la $a0, arg2            # Carrega o endereço da string do valor (argumento 2)
    jal atoi                # Chama a função que converte ASCII para inteiro
    move $s1, $v0           # $s1 = valor a depositar -> Move o resultado (valor) de $v0

    # 3. Atualiza o saldo
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final do saldo: Base + Offset
    lw $t2, 0($a0)          # Carrega o saldo atual da memória para $t2
    add $t2, $t2, $s1       # Soma: $t2 = Saldo Atual ($t2) + Valor Depósito ($s1)
    sw $t2, 0($a0)          # Salva o novo saldo ($t2) de volta na memória

    # 4. Registra no extrato
    move $a0, $s0           # Define o 1º argumento (índice do cliente) para a função
    move $a1, $s1           # Define o 2º argumento (valor do depósito) para a função
    li $a2, 1               # Define o 3º argumento (Tipo 1 = Depósito)
    jal registra_transacao  # Chama a função que salva a transação no histórico

    # 5. Feedback
    li $v0, 4
    la $a0, str_sucesso_dep
    syscall                 # Imprime "Deposito realizado. Novo saldo: R$ "

    # Formata e imprime o valor (R$ XX,XX)
    li $t3, 100             # Carrega 100 para dividir
    div $t2, $t3            # Divide o saldo total ($t2) por 100
    mflo $a0                # Move o quociente (Reais) para $a0
    li $v0, 1
    syscall                 # Imprime a parte dos Reais
    
    li $v0, 4
    la $a0, str_virgula
    syscall                 # Imprime a vírgula

    mfhi $a0                # Move o resto (Centavos) para $a0
    li $v0, 1
    syscall                 # Imprime a parte dos Centavos

    li $v0, 4
    la $a0, str_newline
    syscall                 # Pula uma linha
    j dep_fim

dep_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall                 # Imprime "Falha: cliente inexistente"

dep_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: SACAR
# Formato: sacar-<Conta>-<Valor(centavos)>
# Objetivo: Sacar determinado valor de uma conta
# ==============================================================================
exec_sacar:
    addi $sp, $sp, -4       # Abre espaço na pilha para 1 palavra (4 bytes)
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # 1. Busca o cliente
    # O número da conta foi passado como segundo argumento (arg1) pelo parser.
    la $a0, arg1            # Carrega o endereço da string da conta em $a0
    jal busca_cliente       # Chama a função auxiliar para encontrar o índice do cliente
    move $t0, $v0           # Move o resultado (índice ou -1) para $t0 temporariamente
    li $t1, -1              # Carrega o valor -1 em $t1 para comparação
    beq $t0, $t1, saque_erro_cli # Se índice == -1, cliente não encontrado. Pula para erro.

    # 2. Converte o valor do saque
    # O valor do saque está em arg2 como texto. Precisamos converter para número inteiro.
    move $s0, $t0           # Salva o índice do cliente em $s0 (registrador seguro)
    la $a0, arg2            # Carrega o endereço da string do valor em $a0
    jal atoi                # Chama função auxiliar ASCII to Integer
    move $s1, $v0           # Salva o valor numérico do saque em $s1 (registrador seguro)

    # 3. Verificação de saldo
    # Precisamos saber quanto dinheiro o cliente tem antes de deixar ele sacar.
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s0, 4         # Calcula o deslocamento: índice do cliente * 4 bytes (tamanho de uma word)
    addu $a0, $a0, $t1      # Soma base + deslocamento para ter o endereço exato do saldo deste cliente
    lw $t2, 0($a0)          # Carrega o valor do saldo atual da memória para $t2

    # Compara: se Saldo Atual ($t2) for menor que Valor Saque ($s1), não pode sacar.
    blt $t2, $s1, saque_erro_saldo # Desvia para mensagem de erro se saldo for insuficiente

    # 4. Realiza o saque
    sub $t2, $t2, $s1       # Subtrai o valor do saque do saldo atual ($t2 = $t2 - $s1)
    sw $t2, 0($a0)          # Salva o novo saldo atualizado de volta na memória
    
    # 5. Registra no extrato
    move $a0, $s0           # Índice do cliente
    neg $a1, $s1            # INVERTE o sinal do valor (vira negativo)
    li $a2, 2
    jal registra_transacao

    # 6. Feedback para o usuário
    # Imprime mensagem de sucesso e o novo saldo.
    li $v0, 4               # Syscall 4: print_string
    la $a0, str_sucesso_saque # Carrega mensagem "Saque realizado..."
    syscall

    # -- Formatação simples de moeda (R$ Reais,Centavos) --
    li $t3, 100             # Carrega divisor 100 para separar reais de centavos
    div $t2, $t3            # Divide o saldo total (em centavos) por 100
    mflo $a0                # Move o quociente (parte inteira, os reais) para $a0
    li $v0, 1               # Syscall 1: print_int
    syscall                 # Imprime os reais

    li $v0, 4               # Syscall 4: print_string
    la $a0, str_virgula     # Imprime a vírgula separadora
    syscall

    mfhi $a0                # Move o resto da divisão (os centavos) para $a0
    li $v0, 1               # Syscall 1: print_int
    syscall                 # Imprime os centavos

    li $v0, 4               # Syscall 4: print_string
    la $a0, str_newline     # Pula uma linha para organização do terminal
    syscall
    j saque_fim             # Pula para o fim da função (evita cair nos blocos de erro abaixo)

# --- BLOCOS DE TRATAMENTO DE ERRO ---
saque_erro_saldo:
    li $v0, 4               # Syscall 4: print_string
    la $a0, str_erro_saldo  # Carrega mensagem "Saldo insuficiente"
    syscall
    j saque_fim             # Vai para o fim

saque_erro_cli:
    li $v0, 4               # Syscall 4: print_string
    la $a0, str_erro_cliente # Carrega mensagem "Cliente inexistente"
    syscall

# --- FINALIZAÇÃO DA FUNÇÃO ---
saque_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno original da pilha
    addi $sp, $sp, 4        # Libera o espaço usado na pilha
    j shell_loop            # Retorna para o loop principal do terminal
    
# ==============================================================================
# COMANDO: EXTRATO DE DÉBITO
# Formato: debito_extrato-<conta>
# Objetivo: Listar transações por tipo (Saque, Depósito, Transferência)
# ==============================================================================
exec_debito_extrato:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    la $a0, arg1            # Carrega o endereço da string da conta (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s0, $v0           # Salva o índice do cliente (ou -1) em $s0 (registrador seguro)
    li $t1, -1              # Carrega -1 para comparar
    beq $s0, $t1, extd_erro_cli # Se $s0 == -1 (não achou), pula para o erro

    li $v0, 4
    la $a0, str_extrato_header # Carrega o cabeçalho "--- Extrato de Debitos ---"
    syscall                 # Imprime o cabeçalho

    # Carrega a quantidade de transações que este cliente fez
    la $a0, HISTORICO_DEBITO_QTD # Carrega o endereço base do vetor de contadores
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final do contador deste cliente
    lw $s1, 0($a0)          # Carrega a quantidade de transações em $s1
    beq $s1, $zero, extd_vazio # Se $s1 == 0 (sem transações), pula para msg de extrato vazio

    li $s2, 0               # Inicializa o contador do loop (i = 0) em $s2
extd_loop:
    # Loop: (para i = 0 até i < QtdTransações)
    bge $s2, $s1, extd_fim_loop # (Branch if Greater/Equal) Se i ($s2) >= Qtd ($s1), fim do loop

    # Calcula o endereço da transação [i] na memória
    mul $t2, $s0, 200       # Offset base do cliente: $t2 = índice_cliente * 200 (50 transações * 4 bytes)
    mul $t3, $s2, 4         # Offset da transação: $t3 = i * 4 bytes
    add $t2, $t2, $t3       # $t2 = Offset total (BaseCliente + OffsetTransação)

    # Carrega o VALOR da transação [i]
    la $t4, HISTORICO_DEBITO_VALOR # Carrega o endereço base do vetor de valores
    addu $t4, $t4, $t2      # Calcula o endereço final do valor: Base + OffsetTotal
    lw $s3, 0($t4)          # $s3 = Valor da transação (ex: 5000 ou -2000)

    # Carrega o TIPO da transação [i]
    la $t4, HISTORICO_DEBITO_TIPO # Carrega o endereço base do vetor de tipos
    addu $t4, $t4, $t2      # Calcula o endereço final do tipo: Base + OffsetTotal
    lw $s4, 0($t4)          # $s4 = Tipo (1, 2, 3 ou 4)

    # Verifica o TIPO para imprimir a string certa
    li $t5, 1               # Carrega 1 para comparar
    beq $s4, $t5, extd_print_dep # Se Tipo == 1, pula para imprimir Depósito
    li $t5, 2               # Carrega 2 para comparar
    beq $s4, $t5, extd_print_saque # Se Tipo == 2, pula para imprimir Saque
    li $t5, 3               # Carrega 3 para comparar
    beq $s4, $t5, extd_print_transf_r # Se Tipo == 3, pula para imprimir Transf. Recebida
    li $t5, 4               # Carrega 4 para comparar
    beq $s4, $t5, extd_print_transf_e # Se Tipo == 4, pula para imprimir Transf. Enviada
    j extd_proximo          # Se tipo for desconhecido, pula esta iteração

extd_print_dep:
    li $v0, 4
    la $a0, str_deposito    # Carrega string "DEPOSITO:     +R$ "
    syscall
    move $a0, $s3           # Move o valor (positivo) para $a0
    jal print_dinheiro      # Chama a função que imprime o valor formatado
    j extd_proximo          # Pula para a próxima iteração do loop

extd_print_saque:
    li $v0, 4
    la $a0, str_saque       # Carrega string "SAQUE:        -R$ "
    syscall
    neg $a0, $s3            # Inverte o sinal do valor (ex: -2000 -> 2000)
    jal print_dinheiro      # Chama a função que imprime o valor formatado
    j extd_proximo          # Pula para a próxima iteração

extd_print_transf_r:
    li $v0, 4
    la $a0, str_transf_rec  # Carrega string "TRANSF. RECEBIDA: +R$ "
    syscall
    move $a0, $s3           # Move o valor (positivo) para $a0
    jal print_dinheiro      # Chama a função que imprime o valor formatado
    j extd_proximo          # Pula para a próxima iteração

extd_print_transf_e:
    li $v0, 4
    la $a0, str_transf_env  # Carrega string "TRANSF. ENVIADA:  -R$ "
    syscall
    neg $a0, $s3            # Inverte o sinal do valor (ex: -5000 -> 5000)
    jal print_dinheiro      # Chama a função que imprime o valor formatado

extd_proximo:
    addi $s2, $s2, 1        # Incrementa o contador do loop (i++)
    j extd_loop             # Volta ao início do loop

extd_fim_loop:
    j extd_fim              # Pula para o fim da função

extd_vazio:
    li $v0, 4
    la $a0, str_sem_transacoes # Carrega string "Nenhuma transacao encontrada."
    syscall
    j extd_fim              # Pula para o fim da função

extd_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Carrega string "Falha: cliente inexistente"
    syscall

extd_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: EXTRATO DE CRÉDITO
# Formato: credito_extrato-<conta>
# Objetivo: Listar compras e pagamentos de fatura
# ==============================================================================
exec_credito_extrato:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    la $a0, arg1            # Carrega o endereço da string da conta (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s0, $v0           # Salva o índice do cliente (ou -1) em $s0 (registrador seguro)
    li $t1, -1              # Carrega -1 para comparar
    beq $s0, $t1, extc_erro_cli # Se $s0 == -1 (não achou), pula para o erro

    li $v0, 4
    la $a0, str_ext_cred_header # Carrega o cabeçalho "--- Extrato de Credito ---"
    syscall                 # Imprime o cabeçalho

    # Carrega a quantidade de transações de crédito que este cliente fez
    la $a0, HISTORICO_CREDITO_QTD # Carrega o endereço base do vetor de contadores
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final do contador deste cliente
    lw $s1, 0($a0)          # Carrega a quantidade de transações em $s1
    beq $s1, $zero, extc_vazio # Se $s1 == 0 (sem transações), pula para msg de extrato vazio

    li $s2, 0               # Inicializa o contador do loop (i = 0) em $s2
extc_loop:
    # Loop: (para i = 0 até i < QtdTransações)
    bge $s2, $s1, extc_fim_loop # (Branch if Greater/Equal) Se i ($s2) >= Qtd ($s1), fim do loop

    # Calcula o endereço da transação [i] na memória
    mul $t2, $s0, 200       # Offset base do cliente: $t2 = índice_cliente * 200 (50 transações * 4 bytes)
    mul $t3, $s2, 4         # Offset da transação: $t3 = i * 4 bytes
    add $t2, $t2, $t3       # $t2 = Offset total (BaseCliente + OffsetTransação)

    # Carrega o VALOR da transação [i]
    la $t4, HISTORICO_CREDITO_VALOR # Carrega o endereço base do vetor de valores
    addu $t4, $t4, $t2      # Calcula o endereço final do valor: Base + OffsetTotal
    lw $s3, 0($t4)          # $s3 = Valor da transação (ex: -5000 ou 2000)

    # Carrega o TIPO da transação [i]
    la $t4, HISTORICO_CREDITO_TIPO # Carrega o endereço base do vetor de tipos
    addu $t4, $t4, $t2      # Calcula o endereço final do tipo: Base + OffsetTotal
    lw $s4, 0($t4)          # $s4 = Tipo (1, 2 ou 3)

    # Verifica o TIPO para imprimir a string certa
    li $t5, 1               # Carrega 1 para comparar
    beq $s4, $t5, extc_print_compra # Se Tipo == 1, pula para imprimir Compra
    li $t5, 2               # Carrega 2 para comparar
    beq $s4, $t5, extc_print_pagto # Se Tipo == 2, pula para imprimir Pagamento
    li $t5, 3               # Carrega 3 para comparar
    beq $s4, $t5, extc_print_juros # Se Tipo == 3, pula para imprimir Juros
    j extc_proximo          # Se tipo for desconhecido, pula esta iteração

extc_print_compra:
    li $v0, 4
    la $a0, str_compra      # Carrega string "COMPRA: R$ "
    syscall
    neg $a0, $s3            # Inverte o sinal do valor (ex: -5000 -> 5000)
    jal print_dinheiro      # Chama a função que imprime o valor formatado
    j extc_proximo          # Pula para a próxima iteração

extc_print_pagto:
    li $v0, 4
    la $a0, str_pagto       # Carrega string "PAGTO:  R$ "
    syscall
    move $a0, $s3           # Move o valor (positivo) para $a0
    jal print_dinheiro      # Chama a função que imprime o valor formatado
    j extc_proximo          # Pula para a próxima iteração

extc_print_juros:
    li $v0, 4
    la $a0, str_juros       # Carrega string "JUROS:  R$ "
    syscall
    move $a0, $s3           # Move o valor (positivo) para $a0
    jal print_dinheiro      # Chama a função que imprime o valor formatado

extc_proximo:
    addi $s2, $s2, 1        # Incrementa o contador do loop (i++)
    j extc_loop             # Volta ao início do loop

extc_fim_loop:
    j extc_fim

extc_vazio:
    li $v0, 4
    la $a0, str_sem_transacoes # Carrega string "Nenhuma transacao encontrada."
    syscall
    j extc_fim

extc_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Carrega string "Falha: cliente inexistente"
    syscall

extc_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: TRANSFERIR (DÉBITO)
# Formato: transferir_debito-<ContaDestino>-<ContaOrigem>-<Valor>
# Objetivo: Realiza transfências de débito (saldo)
# ==============================================================================
exec_transferir:
    addi $sp, $sp, -20      # Aloca 20 bytes na pilha (para 5 registradores)
    sw $ra, 16($sp)         # Salva o endereço de retorno ($ra) na pilha
    sw $s0, 12($sp)         # Salva $s0 (será usado para índice da Origem)
    sw $s1, 8($sp)          # Salva $s1 (será usado para o Valor)
    sw $s2, 4($sp)          # Salva $s2 (será usado para índice do Destino)
    sw $s3, 0($sp)          # Salva $s3 (será usado para saldos temporários)

    # 1. BUSCA CONTA ORIGEM (arg2)
    la $a0, arg2            # Carrega o endereço da string da conta de Origem (argumento 2)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s0, $v0           # $s0 = Índice Origem -> Salva o índice (ou -1) em $s0
    li $t0, -1              # Carrega -1 para comparar
    beq $s0, $t0, transf_erro_cli # Se $s0 == -1 (não achou), pula para o erro

    # 2. BUSCA CONTA DESTINO (arg1)
    la $a0, arg1            # Carrega o endereço da string da conta de Destino (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s2, $v0           # $s2 = Índice Destino -> Salva o índice (ou -1) em $s2
    li $t0, -1              # Carrega -1 para comparar
    beq $s2, $t0, transf_erro_cli # Se $s2 == -1 (não achou), pula para o erro

    # 3. CONVERTE VALOR (arg3)
    la $a0, arg3            # Carrega o endereço da string do Valor (argumento 3)
    jal atoi                # Chama a função que converte ASCII para inteiro
    move $s1, $v0           # $s1 = Valor da transferência -> Salva o valor em $s1

    # 4. VERIFICA SALDO DA ORIGEM
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s0, 4         # Calcula o offset da Origem: $t1 = índice_origem ($s0) * 4
    addu $t2, $a0, $t1      # Calcula o endereço final do saldo da Origem: Base + Offset
    lw $s3, 0($t2)          # $s3 = Saldo Atual da Origem -> Carrega o saldo da memória
    
    blt $s3, $s1, transf_erro_saldo # (Branch if Less Than) Se Saldo ($s3) < Valor ($s1), pula para erro

    # 5. REALIZA A TRANSFERÊNCIA
    
    # 5a. Debita da Origem
    sub $s3, $s3, $s1       # Calcula novo saldo: SaldoOrigem - Valor
    sw $s3, 0($t2)          # Salva o novo saldo da Origem na memória

    # 5b. Credita no Destino
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s2, 4         # Calcula o offset do Destino: $t1 = índice_destino ($s2) * 4
    addu $t3, $a0, $t1      # Calcula o endereço final do saldo do Destino: Base + Offset
    lw $s3, 0($t3)          # Carrega o saldo atual do Destino da memória
    add $s3, $s3, $s1       # Calcula novo saldo: SaldoDestino + Valor
    sw $s3, 0($t3)          # Salva o novo saldo do Destino na memória

    # 6. REGISTRA NO EXTRATO DE AMBOS
    # Registra Saque na Origem
    move $a0, $s0           # Define o 1º argumento (índice Origem)
    neg $a1, $s1            # Define o 2º argumento (Valor negativo)
    li $a2, 4               # Define o 3º argumento (Tipo 4 = Transf. Enviada)
    jal registra_transacao  # Chama a função de registro

    # Registra Depósito no Destino
    move $a0, $s2           # Define o 1º argumento (índice Destino)
    move $a1, $s1           # Define o 2º argumento (Valor positivo)
    li $a2, 3               # Define o 3º argumento (Tipo 3 = Transf. Recebida)
    jal registra_transacao  # Chama a função de registro

    # 7. Feedback de Sucesso
    li $v0, 4
    la $a0, str_sucesso_transf
    syscall                 # Imprime "Transferencia realizada com sucesso."
    j transf_fim

transf_erro_saldo:
    li $v0, 4
    la $a0, str_erro_saldo
    syscall                 # Imprime "Falha: saldo insuficiente"
    j transf_fim

transf_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall                 # Imprime "Falha: cliente inexistente"

transf_fim:
    # Restaura tudo antes de sair
    lw $s3, 0($sp)          # Restaura $s3 da pilha
    lw $s2, 4($sp)          # Restaura $s2 da pilha
    lw $s1, 8($sp)          # Restaura $s1 da pilha
    lw $s0, 12($sp)         # Restaura $s0 da pilha
    lw $ra, 16($sp)         # Restaura $ra da pilha
    addi $sp, $sp, 20       # Libera os 20 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: TRANSFERIR (CRÉDITO)
# Formato: transferir_credito-<ContaDestino>-<ContaOrigem>-<Valor>
# Objetivo: Realiza transferências de crédito (limite)
# ==============================================================================
exec_transf_credito:
    addi $sp, $sp, -24      # Aloca 24 bytes na pilha (para 6 registradores)
    sw $ra, 20($sp)         # Salva o endereço de retorno ($ra) na pilha
    sw $s0, 16($sp)         # Salva $s0 (será usado para índice da Origem)
    sw $s1, 12($sp)         # Salva $s1 (será usado para o Valor)
    sw $s2, 8($sp)          # Salva $s2 (será usado para índice do Destino)
    sw $s3, 4($sp)          # Salva $s3 (será usado para Limite da Origem)
    sw $s4, 0($sp)          # Salva $s4 (será usado para Fatura da Origem)

    # 1. Busca Origem (arg2)
    la $a0, arg2            # Carrega o endereço da string da conta de Origem (argumento 2)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s0, $v0           # Salva o índice (ou -1) em $s0
    li $t0, -1
    beq $s0, $t0, tc_erro_cli # Se $s0 == -1 (não achou), pula para o erro

    # 2. Busca Destino (arg1)
    la $a0, arg1            # Carrega o endereço da string da conta de Destino (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s2, $v0           # Salva o índice (ou -1) em $s2
    li $t0, -1
    beq $s2, $t0, tc_erro_cli # Se $s2 == -1 (não achou), pula para o erro

    # 3. Converte Valor (arg3)
    la $a0, arg3            # Carrega o endereço da string do Valor (argumento 3)
    jal atoi                # Chama a função que converte ASCII para inteiro
    move $s1, $v0           # Salva o valor numérico em $s1

    # 4. VERIFICA LIMITE DISPONÍVEL
    # Carrega Limite Total
    la $a0, CLIENTES_LIMITE # Carrega o endereço base do vetor de limites
    mul $t1, $s0, 4         # Calcula o offset da Origem: $t1 = índice_origem ($s0) * 4
    addu $a0, $a0, $t1      # Calcula o endereço final do limite da Origem: Base + Offset
    lw $s3, 0($a0)          # $s3 = Limite Total -> Carrega o limite da memória

    # Carrega Fatura Atual
    la $a0, CLIENTES_FATURA # Carrega o endereço base do vetor de faturas
    # (O offset $t1 ainda é o correto, pois $s0 não mudou)
    addu $a0, $a0, $t1      # Calcula o endereço final da fatura da Origem: Base + Offset
    lw $s4, 0($a0)          # $s4 = Fatura Atual -> Carrega a fatura da memória

    # Calcula Disponível: (Limite - Fatura)
    sub $t2, $s3, $s4       # $t2 = Limite ($s3) - Fatura ($s4)

    # Se Disponível < Valor Solicitado, erro!
    blt $t2, $s1, tc_erro_limite # (Branch if Less Than) Se Disponível ($t2) < Valor ($s1), pula para erro

    # 5. REALIZA A TRANSFERÊNCIA
    # 5a. Aumenta a Fatura da Origem
    add $s4, $s4, $s1       # Nova Fatura = Fatura Atual ($s4) + Valor ($s1)
    la $a0, CLIENTES_FATURA # Carrega o endereço base do vetor de faturas
    mul $t1, $s0, 4         # Recalcula o offset da Origem ($s0)
    addu $a0, $a0, $t1      # Calcula o endereço final da fatura
    sw $s4, 0($a0)          # Salva a nova fatura na memória

    # 5b. Aumenta o Saldo do Destino
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s2, 4         # Calcula o offset do Destino ($s2)
    addu $a0, $a0, $t1      # Calcula o endereço final do saldo do Destino
    lw $t3, 0($a0)          # Carrega o saldo atual do Destino
    add $t3, $t3, $s1       # Novo Saldo = Saldo Atual ($t3) + Valor ($s1)
    sw $t3, 0($a0)          # Salva o novo saldo do Destino na memória

    # 6. REGISTRA NO HISTÓRICO
    # Na origem, registra como uso de CRÉDITO (negativo para indicar gasto)
    move $a0, $s0           # Define o 1º argumento (índice Origem)
    neg $a1, $s1            # Define o 2º argumento (Valor negativo)
    li $a2, 1               # Define o 3º argumento (Tipo 1 = Compra)
    jal registra_credito    # Chama a função de registro (crédito)

    # No destino, é um depósito normal em conta corrente
    move $a0, $s2           # Define o 1º argumento (índice Destino)
    move $a1, $s1           # Define o 2º argumento (Valor positivo)
    jal registra_transacao  # Chama a função de registro (débito)

    # Feedback
    li $v0, 4
    la $a0, str_sucesso_transf # Carrega mensagem "Transferencia realizada com sucesso."
    syscall
    j tc_fim

tc_erro_limite:
    li $v0, 4
    la $a0, str_erro_limite # Carrega mensagem "Falha: limite de credito insuficiente"
    syscall
    j tc_fim

tc_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Carrega mensagem "Falha: cliente inexistente"
    syscall

tc_fim:
    lw $s4, 0($sp)          # Restaura $s4 da pilha
    lw $s3, 4($sp)          # Restaura $s3 da pilha
    lw $s2, 8($sp)          # Restaura $s2 da pilha
    lw $s1, 12($sp)         # Restaura $s1 da pilha
    lw $s0, 16($sp)         # Restaura $s0 da pilha
    lw $ra, 20($sp)         # Restaura $ra da pilha
    addi $sp, $sp, 24       # Libera os 24 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: PAGAR FATURA
# Formato: pagar_fatura-<Conta>-<Valor>-<Modo>
# Modo de pagamento: 'S' = Tira do saldo da Conta, 'E' = Externo (dinheiro físico)
# ==============================================================================
exec_pagar_fatura:
    addi $sp, $sp, -16      # Aloca 16 bytes na pilha (para 4 registradores)
    sw $ra, 12($sp)         # Salva o endereço de retorno ($ra) na pilha
    sw $s0, 8($sp)          # Salva $s0 (será usado para o Índice do Cliente)
    sw $s1, 4($sp)          # Salva $s1 (será usado para o Valor do Pagamento)
    sw $s2, 0($sp)          # Salva $s2 (será usado para o Endereço da Fatura)

    # 1. Busca cliente
    la $a0, arg1            # Carrega o endereço da string da conta (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s0, $v0           # Salva o índice (ou -1) em $s0
    li $t1, -1              # Carrega -1 para comparar
    beq $s0, $t1, pgto_erro_cli # Se $s0 == -1 (não achou), pula para o erro

    # 2. Converte valor
    la $a0, arg2            # Carrega o endereço da string do valor (argumento 2)
    jal atoi                # Chama a função que converte ASCII para inteiro
    move $s1, $v0           # Salva o valor numérico do pagamento em $s1

    # 3. Verifica Modo de Pagamento (arg3)
    la $t0, arg3            # Carrega o endereço da string do modo (argumento 3)
    lb $t1, 0($t0)          # Lê o primeiro caractere de arg3 ('S' ou 'E')
    li $t2, 'S'             # Carrega o caractere 'S' para comparar
    beq $t1, $t2, pgto_modo_saldo # Se for 'S', pula para a lógica de pagamento com saldo
    li $t2, 's'             # Carrega o caractere 's' (minúsculo)
    beq $t1, $t2, pgto_modo_saldo # Se for 's', também pula

    # --- MODO EXTERNO (E) ---
    # (Se não for 'S' ou 's', assume-se 'E')
    j pgto_efetiva          # Pula direto para a parte que reduz a fatura

pgto_modo_saldo:
    # --- MODO SALDO (S) ---
    # Verifica se tem saldo suficiente na conta corrente.
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final do saldo: Base + Offset
    lw $t2, 0($a0)          # Carrega o saldo atual da conta corrente em $t2
    
    blt $t2, $s1, pgto_erro_saldo # (Branch if Less Than) Se Saldo ($t2) < ValorPagamento ($s1), pula para erro

    # Se tem saldo, debita dele
    sub $t2, $t2, $s1       # Calcula novo saldo: SaldoAtual - ValorPagamento
    sw $t2, 0($a0)          # Salva o novo saldo na memória

    # Registra o débito no extrato da conta corrente também
    move $a0, $s0           # Define o 1º argumento (índice cliente)
    neg $a1, $s1            # Define o 2º argumento (Valor negativo, pois é um saque)
    li $a2, 2               # Define o 3º argumento (Tipo 2 = Saque)
    jal registra_transacao  # Chama a função de registro (débito)

pgto_efetiva:
    # 4. REDUZ A FATURA
    la $a0, CLIENTES_FATURA # Carrega o endereço base do vetor de faturas
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $s2, $a0, $t1      # Salva o endereço final da fatura em $s2
    lw $t2, 0($s2)          # Carrega a fatura atual da memória em $t2

    # (Opcional: Verificar se está pagando mais do que deve)
    sub $t2, $t2, $s1       # Calcula nova fatura: FaturaAtual - ValorPagamento
    sw $t2, 0($s2)          # Salva a nova fatura na memória

    # 5. REGISTRA NO HISTÓRICO DE CRÉDITO (Valor positivo = pagamento)
    move $a0, $s0           # Define o 1º argumento (índice cliente)
    move $a1, $s1           # Define o 2º argumento (Valor positivo)
    li $a2, 2               # Define o 3º argumento (Tipo 2 = Pagamento)
    jal registra_credito    # Chama a função de registro (crédito)

    # Feedback
    li $v0, 4
    la $a0, str_sucesso_pagto # Carrega msg "Pagamento de fatura realizado: R$ "
    syscall
    move $a0, $s1           # Move o valor do pagamento para $a0 (argumento)
    jal print_dinheiro      # Chama a função que imprime o valor formatado
    j pgto_fim

pgto_erro_saldo:
    li $v0, 4
    la $a0, str_erro_saldo  # Carrega msg "Falha: saldo insuficiente"
    syscall
    j pgto_fim

pgto_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Carrega msg "Falha: cliente inexistente"
    syscall

pgto_fim:
    lw $s2, 0($sp)          # Restaura $s2 da pilha
    lw $s1, 4($sp)          # Restaura $s1 da pilha
    lw $s0, 8($sp)          # Restaura $s0 da pilha
    lw $ra, 12($sp)         # Restaura $ra da pilha
    addi $sp, $sp, 16       # Libera os 16 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: INFORMAÇÕES DA CONTA
# Formato: conta_info-<Conta>
# Objetivo: Mostrar um resumo rápido de saldo, limite e fatura.
# ==============================================================================
exec_conta_info:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # 1. BUSCA O CLIENTE
    la $a0, arg1            # Carrega o endereço da string da conta (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $s0, $v0           # Salva o índice (ou -1) em $s0 (registrador seguro)
    li $t1, -1              # Carrega -1 para comparar
    beq $s0, $t1, info_erro_cli # Se $s0 == -1 (não achou), pula para o erro

    # 2. IMPRIME CABEÇALHO
    li $v0, 4
    la $a0, str_info_header # Carrega msg "--- Resumo da Conta ---"
    syscall                 # Imprime o cabeçalho

    # 3. MOSTRA SALDO
    li $v0, 4
    la $a0, str_lbl_saldo   # Carrega msg "Saldo em Conta: R$ "
    syscall
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final do saldo: Base + Offset
    lw $a0, 0($a0)          # Carrega o valor do saldo da memória direto para $a0
    jal print_dinheiro      # Chama a função que imprime o valor formatado

    # 4. MOSTRA LIMITE TOTAL
    li $v0, 4
    la $a0, str_lbl_limite  # Carrega msg "Limite Total:   R$ "
    syscall
    la $a0, CLIENTES_LIMITE # Carrega o endereço base do vetor de limites
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final do limite
    lw $s1, 0($a0)          # $s1 = Limite Total -> Carrega o valor do limite em $s1
    move $a0, $s1           # Move o valor (Limite) para $a0 como argumento
    jal print_dinheiro      # Chama a função que imprime o valor formatado

    # 5. MOSTRA FATURA ATUAL
    li $v0, 4
    la $a0, str_lbl_fatura  # Carrega msg "Fatura Atual:   R$ "
    syscall
    la $a0, CLIENTES_FATURA # Carrega o endereço base do vetor de faturas
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final da fatura
    lw $s2, 0($a0)          # $s2 = Fatura Atual -> Carrega o valor da fatura em $s2
    move $a0, $s2           # Move o valor (Fatura) para $a0 como argumento
    jal print_dinheiro      # Chama a função que imprime o valor formatado

    # 6. MOSTRA LIMITE DISPONÍVEL (Limite - Fatura)
    li $v0, 4
    la $a0, str_lbl_disponivel # Carrega msg "Disponivel Cred:R$ "
    syscall
    sub $a0, $s1, $s2       # Calcula o disponível: $a0 = Limite ($s1) - Fatura ($s2)
    jal print_dinheiro      # Chama a função que imprime o valor formatado

    j info_fim

info_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Carrega msg "Falha: cliente inexistente"
    syscall

info_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell

# ==============================================================================
# COMANDO: ALTERAR LIMITE
# Formato: alterar_limite-<Conta>-<NovoLimite(centavos)>
# Objetivo: Atualizar o valor do limite de crédito de um cliente.
# ==============================================================================
exec_alterar_limite:
    addi $sp, $sp, -4       # Abre espaço na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno

    # 1. BUSCA O CLIENTE
    # O número da conta está em arg1. Chamamos a função auxiliar para achar o índice.
    la $a0, arg1
    jal busca_cliente
    move $t0, $v0           # $t0 = índice do cliente encontrado (ou -1 se não achou)
    li $t1, -1
    beq $t0, $t1, lim_erro_cli # Se índice for -1, exibe erro de cliente inexistente

    # 2. CONVERTE O NOVO LIMITE
    # O novo valor está em arg2 como texto. Aqui converte para número inteiro.
    move $s0, $t0           # Salva o índice do cliente em $s0 (registrador seguro)
    la $a0, arg2            # Carrega o endereço da string do valor
    jal atoi                # Chama a função de conversão ASCII para Inteiro
    move $s1, $v0           # $s1 = novo limite (em centavos)

    # 3. ATUALIZA O LIMITE NA MEMÓRIA
    la $a0, CLIENTES_LIMITE # Carrega o endereço base do vetor de limites de crédito
    mul $t1, $s0, 4         # Calcula o deslocamento: índice * 4 bytes
    addu $a0, $a0, $t1      # Endereço final = Base + Deslocamento
    sw $s1, 0($a0)          # Salva o novo limite na posição correta da memória

    # 4. FEEDBACK PARA O USUÁRIO
    li $v0, 4               # Syscall para imprimir string
    la $a0, str_sucesso_limite # Imprime "Limite de credito alterado..."
    syscall

    # Usa a função auxiliar para imprimir o valor formatado (R$ XX,XX)
    move $a0, $s1           # Passa o novo limite como argumento
    jal print_dinheiro      # Chama a função de impressão formatada

    j lim_fim               # Pula para o fim da função

lim_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Imprime mensagem de erro se cliente não foi achado
    syscall

lim_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno original
    addi $sp, $sp, 4        # Libera a pilha
    j shell_loop            # Volta para o loop principal do terminal

# ==============================================================================
# COMANDO: FORMATAR CONTA
# Formato: conta_format-<Conta>
# Objetivo: Apagar o histórico de transações de um cliente.
# ==============================================================================
exec_conta_format:
    addi $sp, $sp, -4       # Abre espaço na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno

    # 1. BUSCA O CLIENTE
    la $a0, arg1            # O número da conta está em arg1
    jal busca_cliente
    move $s0, $v0           # $s0 = índice do cliente
    li $t1, -1
    beq $s0, $t1, fmt_erro_cli # Se não achou, exibe erro

    # 2. PEDE CONFIRMAÇÃO
    li $v0, 4
    la $a0, str_confirma_fmt # "Tem certeza...? (s/n): "
    syscall

    # Lê a resposta do usuário (s ou n)
    li $v0, 8               # Syscall para ler string
    la $a0, buffer_resp     # Buffer onde salvar a resposta
    li $a1, 4               # Tamanho máximo
    syscall

    # Verifica se a resposta foi 's' (sim)
    la $t0, buffer_resp
    lb $t1, 0($t0)          # Lê o primeiro caractere da resposta
    li $t2, 's'             # Carrega o caractere 's' para comparar
    bne $t1, $t2, fmt_cancela # Se não for 's', cancela a operação

    # 3. EXECUTA A FORMATAÇÃO (Zera o contador de transações)
    la $a0, HISTORICO_DEBITO_QTD # Endereço base do vetor de quantidades
    mul $t1, $s0, 4         # Offset = índice do cliente * 4
    addu $a0, $a0, $t1      # Endereço exato do contador deste cliente
    sw $zero, 0($a0)        # Salva 0 na memória, efetivamente apagando o histórico

    # Feedback de sucesso
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_sucesso_fmt # Carrega o endereço da msg "Historico apagado com sucesso."
    syscall                 # Imprime a mensagem
    j fmt_fim               # (Jump) Pula para o final da função

fmt_cancela:
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_cancela_fmt # Carrega o endereço da msg "Operacao cancelada."
    syscall                 # Imprime a mensagem
    j fmt_fim               # (Jump) Pula para o final da função

fmt_erro_cli:
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_erro_cliente # Carrega o endereço da msg "Falha: cliente inexistente"
    syscall                 # Imprime a mensagem
    # (O fluxo continua para fmt_fim)

fmt_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: FECHAR CONTA
# Formato: conta_fechar-<Conta>
# Objetivo: Encerrar uma conta se ela não tiver saldo nem dívidas.
# ==============================================================================
exec_conta_fechar:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # 1. BUSCA O CLIENTE
    la $a0, arg1            # Carrega o endereço da string da conta (argumento 1)
    jal busca_cliente       # Chama a função que procura o cliente
    move $t0, $v0           # Move o resultado (índice ou -1) de $v0 para $t0
    li $t1, -1              # Carrega -1 para comparar
    beq $t0, $t1, fechar_erro_cli # Se $t0 == -1 (não achou), pula para o erro

    # 2. VERIFICA SE TEM SALDO (Deve ser zero para fechar)
    move $s0, $t0           # Salva o índice do cliente em $s0 (registrador seguro)
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final do saldo: Base + Offset
    lw $s1, 0($a0)          # Carrega o saldo atual da memória em $s1

    bne $s1, $zero, fechar_erro_saldo # (Branch if Not Equal) Se Saldo ($s1) != 0, pula para erro

    # 3. "APAGA" O CLIENTE
    # Truque: Marca a conta como inativa colocando um '*' no início.
    # Isso fará com que a função 'busca_cliente' não a encontre mais.
    la $a0, CLIENTES_CONTA  # Carrega o endereço base do vetor de contas
    mul $t1, $s0, 7         # Calcula o offset: $t1 = índice ($s0) * 7 bytes (tamanho da string conta)
    addu $a0, $a0, $t1      # Calcula o endereço final da string da conta
    li $t2, '*'             # Carrega o caractere ASCII '*' em $t2
    sb $t2, 0($a0)          # (Store Byte) Salva o '*' no primeiro byte da string da conta, sobrescrevendo-a

    # 4. FEEDBACK DE SUCESSO
    li $v0, 4
    la $a0, str_sucesso_fechar # Carrega msg "Conta fechada com sucesso."
    syscall                 # Imprime a mensagem
    j fechar_fim            # Pula para o final da função

fechar_erro_saldo:
    li $v0, 4
    la $a0, str_erro_fechar # Carrega msg "Falha: conta ainda possui saldo de R$ "
    syscall
    move $a0, $s1           # Move o saldo restante ($s1) para $a0 (argumento)
    jal print_dinheiro      # Chama a função que imprime o valor formatado
    j fechar_fim            # Pula para o final da função

fechar_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Carrega msg "Falha: cliente inexistente"
    syscall
    # (O fluxo continua para fechar_fim)

fechar_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: AJUSTAR DATA E HORA
# Formato: data_hora-<DDMMAAAA>-<HHMMSS>
# ==============================================================================
exec_data_hora:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # 1. Converte Data (arg1) para inteiro
    la $a0, arg1            # Carrega o endereço da string da Data (argumento 1)
    jal atoi                # Chama a função que converte ASCII para inteiro
    move $t0, $v0           # $t0 = DDMMAAAA -> Salva o valor numérico da data em $t0

    # 2. Extrai Dia, Mês, Ano usando divisões
    # Ano = DDMMAAAA % 10000
    li $t1, 10000           # Carrega 10000 para dividir/pegar o resto
    div $t0, $t1            # Divide DDMMAAAA / 10000
    mfhi $t2                # $t2 = AAAA -> (Move From HI) Move o RESTO (AAAA) para $t2
    sw $t2, DATA_ANO        # Salva o Ano na variável global DATA_ANO
    mflo $t0                # $t0 = DDMM -> (Move From LO) Move o QUOCIENTE (DDMM) para $t0

    # Mês = DDMM % 100
    li $t1, 100             # Carrega 100 para dividir/pegar o resto
    div $t0, $t1            # Divide DDMM / 100
    mfhi $t2                # $t2 = MM -> Move o RESTO (MM) para $t2
    sw $t2, DATA_MES        # Salva o Mês na variável global DATA_MES
    mflo $t2                # $t2 = DD -> Move o QUOCIENTE (DD) para $t2
    sw $t2, DATA_DIA        # Salva o Dia na variável global DATA_DIA

    # 3. Converte Hora (arg2) para inteiro
    la $a0, arg2            # Carrega o endereço da string da Hora (argumento 2)
    jal atoi                # Chama a função que converte ASCII para inteiro
    move $t0, $v0           # $t0 = HHMMSS -> Salva o valor numérico da hora em $t0

    # 4. Extrai Hora, Minuto, Segundo
    # Segundo = HHMMSS % 100
    li $t1, 100             # Carrega 100 para dividir/pegar o resto
    div $t0, $t1            # Divide HHMMSS / 100
    mfhi $t2                # $t2 = SS -> Move o RESTO (SS) para $t2
    sw $t2, HORA_S          # Salva o Segundo na variável global HORA_S
    mflo $t0                # $t0 = HHMM -> Move o QUOCIENTE (HHMM) para $t0

    # Minuto = HHMM % 100
    div $t0, $t1            # Divide HHMM / 100
    mfhi $t2                # $t2 = MM -> Move o RESTO (MM) para $t2
    sw $t2, HORA_M          # Salva o Minuto na variável global HORA_M
    mflo $t2                # $t2 = HH -> Move o QUOCIENTE (HH) para $t2
    sw $t2, HORA_H          # Salva a Hora na variável global HORA_H

    # Pega a hora atual do sistema (syscall 30)
    li $v0, 30              # Carrega o código 30 (syscall: get_time)
    syscall                 # Executa. $a0 recebe o tempo atual em ms
    # Salva como a "última vez checada" para iniciar o ciclo
    sw $a0, LAST_TIME_CHECK # Salva o timestamp atual na memória

    # 5. Feedback
    li $v0, 4
    la $a0, str_sucesso_data # Carrega msg "Data e hora do sistema atualizadas."
    syscall                 # Imprime a mensagem

    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: VER HORA ATUAL
# Formato: ver_hora
# ==============================================================================
exec_ver_hora:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # Imprime "Data/Hora atual: "
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_data_atual  # Carrega o endereço da string "Data/Hora atual: "
    syscall                 # Imprime a string

    # --- Imprime a Data (DD/MM/AAAA) ---
    lw $a0, DATA_DIA        # Carrega o valor do Dia da memória para $a0
    li $v0, 1               # Carrega o código 1 (syscall: print_int)
    syscall                 # Imprime o Dia
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_barra       # Carrega o endereço da string "/"
    syscall                 # Imprime a barra
    
    lw $a0, DATA_MES        # Carrega o valor do Mês da memória para $a0
    li $v0, 1
    syscall                 # Imprime o Mês
    li $v0, 4
    la $a0, str_barra
    syscall                 # Imprime a barra
    
    lw $a0, DATA_ANO        # Carrega o valor do Ano da memória para $a0
    li $v0, 1
    syscall                 # Imprime o Ano
    li $v0, 4
    la $a0, str_espaco      # Carrega o endereço da string " "
    syscall                 # Imprime um espaço

    # --- Imprime a Hora (HH:MM:SS) ---
    lw $a0, HORA_H          # Carrega o valor da Hora da memória para $a0
    li $v0, 1
    syscall                 # Imprime a Hora
    li $v0, 4
    la $a0, str_dois_pontos # Carrega o endereço da string ":"
    syscall                 # Imprime dois pontos
    
    lw $a0, HORA_M          # Carrega o valor do Minuto da memória para $a0
    li $v0, 1
    syscall                 # Imprime o Minuto
    li $v0, 4
    la $a0, str_dois_pontos
    syscall                 # Imprime dois pontos

    lw $a0, HORA_S          # Carrega o valor do Segundo da memória para $a0
    li $v0, 1
    syscall                 # Imprime o Segundo
    li $v0, 4
    la $a0, str_newline     # Carrega o endereço da string "\n" (nova linha)
    syscall                 # Pula uma linha

    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: CALCULO DE JUROS
# Objetivo: Aplicar 1% de juros na fatura de TODOS os clientes a cada minuto.
# ==============================================================================
exec_calcula_juros:
    addi $sp, $sp, -16      # Aloca 16 bytes na pilha (para 4 registradores)
    sw $ra, 12($sp)         # Salva o endereço de retorno ($ra) na pilha
    sw $s0, 8($sp)          # Salva $s0 (será usado para o índice do loop)
    sw $s1, 4($sp)          # Salva $s1 (será usado para a Fatura)
    sw $s2, 0($sp)          # Salva $s2 (será usado para o valor do Juros)

    li $s0, 0               # Inicia o contador do loop (índice do cliente) em $s0 = 0
juros_loop:
    lw $t0, MAX_CLIENTES    # Carrega o número máximo de clientes em $t0
    bge $s0, $t0, juros_fim_loop # (Branch if Greater/Equal) Se índice ($s0) >= max ($t0), fim do loop

    # 1. Carrega fatura do cliente [i]
    la $a0, CLIENTES_FATURA # Carrega o endereço base do vetor de faturas
    mul $t1, $s0, 4         # Calcula o offset: $t1 = índice ($s0) * 4 bytes
    addu $a0, $a0, $t1      # Calcula o endereço final da fatura: Base + Offset
    lw $s1, 0($a0)          # $s1 = Fatura atual -> Carrega o valor da fatura da memória

    # 2. Se fatura <= 0, não faz nada, pula para próximo cliente
    ble $s1, $zero, juros_proximo # (Branch if Less/Equal) Se Fatura ($s1) <= 0, pula

    # 3. Calcula juros (1%)
    # Juros = (Fatura * 1) / 100
    li $t2, 100             # Carrega 100 em $t2 (para a divisão)
    div $s1, $t2            # Divide Fatura ($s1) / 100 ($t2)
    mflo $s2                # $s2 = Valor do juros -> (Move From LO) Move o quociente (1%) para $s2

    # 4. Soma juros à fatura
    add $s1, $s1, $s2       # Calcula nova fatura: Fatura Atual ($s1) + Juros ($s2)
    sw $s1, 0($a0)          # Salva a nova fatura (com juros) de volta na memória

    # 5. Registra no extrato de crédito
    move $a0, $s0           # Define o 1º argumento (índice cliente)
    move $a1, $s2           # Define o 2º argumento (valor do juros)
    li $a2, 3               # Define o 3º argumento (Tipo 3 = Juros)
    jal registra_credito    # Chama a função que salva a transação no histórico

juros_proximo:
    addi $s0, $s0, 1        # Incrementa o índice do loop (próximo cliente)
    j juros_loop            # (Jump) Volta ao início do loop

juros_fim_loop:
    lw $s2, 0($sp)          # Restaura $s2 da pilha
    lw $s1, 4($sp)          # Restaura $s1 da pilha
    lw $s0, 8($sp)          # Restaura $s0 da pilha
    lw $ra, 12($sp)         # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 16       # Libera os 16 bytes da pilha
    jr $ra                  # (Jump Register) Retorna para onde a função foi chamada

# ==============================================================================
# COMANDO: FORMATAR (TUDO)
# Formato: formatar
# Objetivo: Apagar todos os clientes e transações da memória. 
# ==============================================================================
exec_formatar:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # 1. PEDE CONFIRMAÇÃO
    li $v0, 4               # Carrega o código 4 (syscall: print_string)
    la $a0, str_confirma_fmt_g # Carrega o endereço da string de confirmação
    syscall                 # Imprime a pergunta de confirmação

    # Lê a resposta do usuário (s ou n)
    li $v0, 8               # Carrega o código 8 (syscall: read_string)
    la $a0, buffer_resp     # Define o buffer de destino para a resposta
    li $a1, 4               # Define o tamanho máximo (4 bytes)
    syscall                 # Lê a resposta (ex: "s\n")

    # Verifica se a resposta foi 's' (sim)
    la $t0, buffer_resp     # Carrega o endereço do buffer de resposta em $t0
    lb $t1, 0($t0)          # (Load Byte) Carrega o primeiro caractere da resposta em $t1
    li $t2, 's'             # Carrega o caractere ASCII 's' em $t2
    bne $t1, $t2, fmt_g_cancela # (Branch if Not Equal) Se $t1 != 's', pula para cancelar

    # 2. EXECUTA A FORMATAÇÃO
    # "Apaga tudo" zerando o contador de clientes.
    # Novos clientes começarão a sobrescrever os antigos a partir do índice 0.
    sw $zero, QTD_CLIENTES  # Salva o valor 0 ($zero) na variável QTD_CLIENTES

    # Feedback de sucesso
    li $v0, 4
    la $a0, str_sucesso_fmt_g # Carrega msg "Banco de dados zerado com sucesso."
    syscall                 # Imprime a mensagem
    j fmt_g_fim             # (Jump) Pula para o final da função

fmt_g_cancela:
    li $v0, 4
    la $a0, str_cancela_fmt # Carrega msg "Operacao cancelada."
    syscall                 # Imprime a mensagem
    # (O fluxo continua para fmt_g_fim)

fmt_g_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell
    
# ==============================================================================
# COMANDO: SALVAR
# Formato: salvar
# Objetivo: Gravar o estado atual do banco em um arquivo "banco.dat"
# ==============================================================================
exec_salvar:
    addi $sp, $sp, -8       # Aloca 8 bytes na pilha
    sw $ra, 4($sp)          # Salva o endereço de retorno ($ra) na pilha
    sw $s0, 0($sp)          # Salva $s0 (será usado para o File Descriptor)

    # 1. ABRIR O ARQUIVO (Syscall 13)
    # Abre o arquivo para ESCRITA (flag = 1)
    li $v0, 13              # Carrega o código 13 (syscall: open_file)
    la $a0, filename        # Define o 1º argumento (endereço do nome do arquivo)
    li $a1, 1               # Define o 2º argumento (Flag 1 = Escrita)
    li $a2, 0               # Define o 3º argumento (Modo, 0 = padrão)
    syscall                 # Executa. $v0 recebe o File Descriptor (FD)
    
    # $v0 retorna o "File Descriptor" (FD). Se for < 0, deu erro.
    blt $v0, $zero, salvar_erro # (Branch if Less Than) Se FD < 0, pula para erro
    move $s0, $v0           # Salva o FD (File Descriptor) em $s0

    # 2. ESCREVER OS DADOS NO ARQUIVO (Syscall 15)
    # Syscall 15: li $v0, 15 | $a0 = FD | $a1 = Endereço na memória | $a2 = Qtd de bytes

    # --- Bloco 1: QTD_CLIENTES (4 bytes) ---
    li $v0, 15              # Carrega o código 15 (syscall: write_file)
    move $a0, $s0           # Define o 1º argumento (FD)
    la $a1, QTD_CLIENTES    # Define o 2º argumento (endereço do dado)
    li $a2, 4               # Define o 3º argumento (tamanho em bytes)
    syscall                 # Executa (escreve no arquivo)
    
    # --- Bloco 2: CLIENTES_CPF (600 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, CLIENTES_CPF
    li $a2, 600             # Tamanho: 50 clientes * 12 bytes
    syscall

    # --- Bloco 3: CLIENTES_CONTA (350 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, CLIENTES_CONTA
    li $a2, 350             # Tamanho: 50 clientes * 7 bytes
    syscall
    
    # --- Bloco 4: CLIENTES_NOME (2500 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, CLIENTES_NOME
    li $a2, 2500            # Tamanho: 50 clientes * 50 bytes
    syscall

    # --- Bloco 5: CLIENTES_SALDO (50 * 4 = 200 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, CLIENTES_SALDO
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes (word)
    syscall
    
    # --- Bloco 6: CLIENTES_LIMITE (200 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, CLIENTES_LIMITE
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 7: CLIENTES_FATURA (200 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, CLIENTES_FATURA
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 8: HISTORICO_DEBITO_VALOR (2500 * 4 = 10000 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, HISTORICO_DEBITO_VALOR
    li $a2, 10000           # Tamanho: 2500 transações * 4 bytes
    syscall
    
    # --- Bloco 9: HISTORICO_DEBITO_QTD (50 * 4 = 200 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, HISTORICO_DEBITO_QTD
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 10: HISTORICO_CREDITO_VALOR (10000 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, HISTORICO_CREDITO_VALOR
    li $a2, 10000           # Tamanho: 2500 transações * 4 bytes
    syscall
    
    # --- Bloco 11: HISTORICO_CREDITO_QTD (200 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, HISTORICO_CREDITO_QTD
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 12: HISTORICO_CREDITO_TIPO (10000 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, HISTORICO_CREDITO_TIPO
    li $a2, 10000           # Tamanho: 2500 transações * 4 bytes
    syscall
    
    # --- Bloco 13: O RELÓGIO (6 words = 24 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, DATA_DIA        # Define o endereço do início do bloco do relógio
    li $a2, 24              # Tamanho: 6 variáveis * 4 bytes
    syscall
    
    # --- Bloco 14: CONTROLE DE TEMPO (2 words = 8 bytes) ---
    li $v0, 15
    move $a0, $s0
    la $a1, LAST_TIME_CHECK # Define o endereço do início do bloco de controle
    li $a2, 8               # Tamanho: 2 variáveis * 4 bytes
    syscall
    
    # 3. FECHAR O ARQUIVO (Syscall 16)
    li $v0, 16              # Carrega o código 16 (syscall: close_file)
    move $a0, $s0           # Define o 1º argumento (FD do arquivo a fechar)
    syscall                 # Executa (fecha o arquivo)

    # 4. FEEDBACK DE SUCESSO
    li $v0, 4
    la $a0, str_sucesso_salvar # Carrega msg "Dados salvos com sucesso..."
    syscall
    j salvar_fim            # Pula para o final da função

salvar_erro:
    li $v0, 4
    la $a0, str_erro_salvar # Carrega msg "Falha ao abrir/salvar o arquivo."
    syscall
    # (O fluxo continua para salvar_fim)

salvar_fim:
    lw $s0, 0($sp)          # Restaura $s0 da pilha
    lw $ra, 4($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 8        # Libera os 8 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell

# ==============================================================================
# COMANDO: RECARREGAR
# Formato esperado: recarregar
# Objetivo: Ler o arquivo "banco.dat" e carregar na memória.
# ==============================================================================
exec_recarregar:
    addi $sp, $sp, -8       # Aloca 8 bytes na pilha
    sw $ra, 4($sp)          # Salva o endereço de retorno ($ra) na pilha
    sw $s0, 0($sp)          # Salva $s0 (será usado para o File Descriptor)

    # 1. ABRIR O ARQUIVO (Syscall 13)
    # Abre o arquivo para LEITURA (flag = 0)
    li $v0, 13              # Carrega o código 13 (syscall: open_file)
    la $a0, filename        # Define o 1º argumento (endereço do nome do arquivo)
    li $a1, 0               # Define o 2º argumento (Flag 0 = Leitura)
    li $a2, 0               # Define o 3º argumento (Modo)
    syscall                 # Executa. $v0 recebe o File Descriptor (FD)
    
    blt $v0, $zero, recar_erro # (Branch if Less Than) Se FD < 0, pula para erro
    move $s0, $v0           # Salva o FD (File Descriptor) em $s0

    # 2. LER OS DADOS DO ARQUIVO (Syscall 14)
    # Syscall 14: li $v0, 14 | $a0 = FD | $a1 = Endereço de destino na memória | $a2 = Qtd de bytes
    
    # --- Bloco 1: QTD_CLIENTES (4 bytes) ---
    li $v0, 14              # Carrega o código 14 (syscall: read_file)
    move $a0, $s0           # Define o 1º argumento (FD)
    la $a1, QTD_CLIENTES    # Define o 2º argumento (endereço de destino)
    li $a2, 4               # Define o 3º argumento (tamanho em bytes)
    syscall                 # Executa (lê do arquivo)
    
    # --- Bloco 2: CLIENTES_CPF (600 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, CLIENTES_CPF
    li $a2, 600             # Tamanho: 50 clientes * 12 bytes
    syscall

    # --- Bloco 3: CLIENTES_CONTA (350 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, CLIENTES_CONTA
    li $a2, 350             # Tamanho: 50 clientes * 7 bytes
    syscall
    
    # --- Bloco 4: CLIENTES_NOME (2500 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, CLIENTES_NOME
    li $a2, 2500            # Tamanho: 50 clientes * 50 bytes
    syscall

    # --- Bloco 5: CLIENTES_SALDO (200 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, CLIENTES_SALDO
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 6: CLIENTES_LIMITE (200 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, CLIENTES_LIMITE
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 7: CLIENTES_FATURA (200 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, CLIENTES_FATURA
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 8: HISTORICO_DEBITO_VALOR (10000 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, HISTORICO_DEBITO_VALOR
    li $a2, 10000           # Tamanho: 2500 transações * 4 bytes
    syscall
    
    # --- Bloco 9: HISTORICO_DEBITO_QTD (200 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, HISTORICO_DEBITO_QTD
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 10: HISTORICO_CREDITO_VALOR (10000 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, HISTORICO_CREDITO_VALOR
    li $a2, 10000           # Tamanho: 2500 transações * 4 bytes
    syscall
    
    # --- Bloco 11: HISTORICO_CREDITO_QTD (200 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, HISTORICO_CREDITO_QTD
    li $a2, 200             # Tamanho: 50 clientes * 4 bytes
    syscall
    
    # --- Bloco 12: HISTORICO_CREDITO_TIPO (10000 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, HISTORICO_CREDITO_TIPO
    li $a2, 10000           # Tamanho: 2500 transações * 4 bytes
    syscall
    
    # --- Bloco 13: O RELÓGIO (24 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, DATA_DIA        # Define o endereço de destino (início do bloco do relógio)
    li $a2, 24              # Tamanho: 6 variáveis * 4 bytes
    syscall
    
    # --- Bloco 14: CONTROLE DE TEMPO (8 bytes) ---
    li $v0, 14
    move $a0, $s0
    la $a1, LAST_TIME_CHECK # Define o endereço de destino (início do bloco de controle)
    li $a2, 8               # Tamanho: 2 variáveis * 4 bytes
    syscall
    
    # 3. FECHAR O ARQUIVO (Syscall 16)
    li $v0, 16              # Carrega o código 16 (syscall: close_file)
    move $a0, $s0           # Define o 1º argumento (FD do arquivo a fechar)
    syscall                 # Executa (fecha o arquivo)

    # 4. FEEDBACK DE SUCESSO
    li $v0, 4
    la $a0, str_sucesso_recar # Carrega msg "Dados recarregados com sucesso."
    syscall
    j recar_fim             # Pula para o final da função

recar_erro:
    li $v0, 4
    la $a0, str_erro_recar  # Carrega msg "Falha ao abrir/ler o arquivo."
    syscall
    # (O fluxo continua para recar_fim)

recar_fim:
    lw $s0, 0($sp)          # Restaura $s0 da pilha
    lw $ra, 4($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 8        # Libera os 8 bytes da pilha
    j shell_loop            # Volta para o loop principal do shell

# ==============================================================================
# FUNÇÕES AUXILIARES (HELPERS)
# ==============================================================================

parser_comandos:
    addi $sp, $sp, -4       # Aloca 4 bytes na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha
    move $t9, $a0           # Copia o ponteiro da string de entrada (de $a0) para $t9
    
    # Extrai arg0 (o comando)
    la $a0, arg0            # Define o 1º argumento (destino) como o buffer arg0
    move $a1, $t9           # Define o 2º argumento (origem) como o ponteiro $t9
    li $a2, '-'             # Define o 3º argumento (delimitador) como '-'
    jal copy_token          # Chama a função que copia até o delimitador
    move $t9, $v0           # Atualiza $t9 com o novo ponteiro (retornado em $v0)

    # Extrai arg1
    la $a0, arg1            # Define o destino como o buffer arg1
    move $a1, $t9           # Define a origem como a posição atual
    li $a2, '-'             # Define o delimitador como '-'
    jal copy_token          # Copia o próximo token
    move $t9, $v0           # Atualiza $t9

    # Extrai arg2
    la $a0, arg2            # Define o destino como o buffer arg2
    move $a1, $t9           # Define a origem como a posição atual
    li $a2, '-'             # Define o delimitador como '-'
    jal copy_token          # Copia o próximo token
    move $t9, $v0           # Atualiza $t9

    # Extrai arg3 (o resto da linha)
    la $a0, arg3            # Define o destino como o buffer arg3
    move $a1, $t9           # Define a origem como a posição atual
    li $a2, 10              # Define o delimitador como '\n' (nova linha)
    jal copy_token          # Copia o token final
    
    lw $ra, 0($sp)          # Restaura o endereço de retorno ($ra) da pilha
    addi $sp, $sp, 4        # Libera os 4 bytes da pilha
    jr $ra                  # (Jump Register) Retorna para onde a função foi chamada

# Função auxiliar do parser: copia de $a1 para $a0 até achar $a2 ou fim da linha
copy_token:
    move $t8, $a0           # Copia o ponteiro de destino ($a0) para $t8
    move $t7, $a1           # Copia o ponteiro de origem ($a1) para $t7
ct_loop:
    lb $t6, 0($t7)          # (Load Byte) Carrega o caractere da origem em $t6
    beq $t6, $zero, ct_fim  # Se for \0 (nulo), pula para o fim
    beq $t6, 10, ct_fim     # Se for \n (nova linha), pula para o fim
    beq $t6, 13, ct_fim     # Se for \r (carriage return), pula para o fim
    beq $t6, $a2, ct_achou_delim # Se for o delimitador (em $a2), pula
    
    sb $t6, 0($t8)          # (Store Byte) Salva o caractere no destino
    addi $t8, $t8, 1        # Avança o ponteiro de destino
    addi $t7, $t7, 1        # Avança o ponteiro de origem
    j ct_loop               # Volta ao início do loop
ct_achou_delim:
    sb $zero, 0($t8)        # Adiciona o caractere \0 (nulo) no fim da string de destino
    addi $v0, $t7, 1        # Retorna o endereço DEPOIS do delimitador (para o próximo token)
    jr $ra                  # Retorna
ct_fim:
    sb $zero, 0($t8)        # Adiciona o caractere \0 (nulo) no fim da string de destino
    move $v0, $t7           # Retorna o endereço atual (fim da string)
    jr $ra                  # Retorna

calcula_dv:
    move $t0, $a0           # Copia o ponteiro da string da conta (de $a0) para $t0
    li $t7, 0               # Inicializa o acumulador ($t7) com 0
    li $t3, 7               # Inicializa o peso ($t3) com 7 (para o primeiro dígito)
    li $t4, 0               # Inicializa o contador do loop ($t4) com 0
cdv_loop:
    lb $t1, 0($t0)          # (Load Byte) Carrega o dígito (ASCII) em $t1
    beq $t1, $zero, cdv_calc_final # Se for \0 (nulo), pula para o cálculo final
    subu $t1, $t1, 48       # Converte o dígito ASCII para inteiro (ex: '1' (49) -> 1)
    mult $t1, $t3           # Multiplica o dígito ($t1) pelo peso ($t3) (resultado em HI/LO)
    mflo $t1                # (Move From LO) Move o resultado da multiplicação para $t1
    addu $t7, $t7, $t1      # Soma o resultado ao acumulador ($t7)
    addi $t0, $t0, 1        # Avança o ponteiro da string
    addi $t3, $t3, -1       # Decrementa o peso (7 -> 6 -> 5...)
    addi $t4, $t4, 1        # Incrementa o contador do loop
    blt $t4, 6, cdv_loop    # (Branch if Less Than) Se contador < 6, repete o loop
cdv_calc_final:
    li $t2, 11              # Carrega 11 para a divisão
    div $t7, $t2            # Divide o Acumulador ($t7) por 11
    mfhi $v0                # (Move From HI) Move o RESTO (o DV) para $v0 (retorno)
    jr $ra                  # Retorna

strcmp:
    move $t0, $a0           # Copia o ponteiro da string 1 (de $a0) para $t0
    move $t1, $a1           # Copia o ponteiro da string 2 (de $a1) para $t1
strcmp_l:
    lb $t2, 0($t0)          # Carrega o caractere da string 1
    lb $t3, 0($t1)          # Carrega o caractere da string 2
    bne $t2, $t3, strcmp_ne # (Branch if Not Equal) Se Caractere1 != Caractere2, pula (são diferentes)
    beq $t2, $zero, strcmp_eq # Se Caractere1 == \0 (e são iguais), pula (são iguais)
    addi $t0, $t0, 1        # Avança o ponteiro da string 1
    addi $t1, $t1, 1        # Avança o ponteiro da string 2
    j strcmp_l              # Volta ao início do loop
strcmp_eq:
    li $v0, 0               # Retorna 0 (iguais)
    jr $ra                  # Retorna
strcmp_ne:
    li $v0, 1               # Retorna 1 (diferentes) - simplificado
    jr $ra                  # Retorna

strcpy:
    move $t0, $a0           # Copia o ponteiro de destino ($a0) para $t0
    move $t1, $a1           # Copia o ponteiro de origem ($a1) para $t1
strcpy_l:
    lb $t2, 0($t1)          # (Load Byte) Carrega o caractere da origem
    sb $t2, 0($t0)          # (Store Byte) Salva o caractere no destino
    beq $t2, $zero, strcpy_f # Se o caractere for \0 (nulo), pula para o fim
    addi $t0, $t0, 1        # Avança o ponteiro de destino
    addi $t1, $t1, 1        # Avança o ponteiro de origem
    j strcpy_l              # Volta ao início do loop
strcpy_f:
    jr $ra                  # Retorna

# ==============================================================================
# COMANDO: SAIR DO SISTEMA
# ==============================================================================
fim_programa:
    li $v0, 10              # Carrega o código 10 (syscall: exit)
    syscall                 # Encerra o programa
    
# ==============================================================================
# BUSCA CLIENTE POR CONTA
# ==============================================================================
busca_cliente:
    addi $sp, $sp, -12      # Aloca 12 bytes na pilha (para 3 registradores)
    sw $ra, 8($sp)          # Salva o endereço de retorno ($ra) na pilha
    sw $s0, 4($sp)          # Salva $s0 (será usado para o índice do loop)
    sw $s1, 0($sp)          # Salva $s1 (será usado para a conta procurada)

    move $s1, $a0           # Salva a conta procurada ($a0) em $s1
    li $s0, 0               # Inicializa o índice do loop ($s0) com 0
bc_loop:
    lw $t0, QTD_CLIENTES    # Carrega a quantidade total de clientes em $t0
    bge $s0, $t0, bc_nao_achou # Se índice ($s0) >= Qtd ($t0), pula (não achou)

    # Calcula endereço da conta do cliente atual [i]
    la $a0, CLIENTES_CONTA  # Carrega o endereço base do vetor de contas
    li $t1, 7               # Carrega o tamanho 7 (tamanho da string conta)
    mul $t2, $s0, $t1       # Calcula o offset: $t2 = índice ($s0) * 7
    addu $a0, $a0, $t2      # Calcula o endereço final: Base + Offset
    move $a1, $s1           # Move a conta procurada para $a1 (argumento do strcmp)
    jal strcmp              # Compara a conta[i] com a conta procurada
    beq $v0, 0, bc_achou    # Se $v0 == 0 (iguais), pula (achou!)

    addi $s0, $s0, 1        # Incrementa o índice (próximo cliente)
    j bc_loop               # Volta ao início do loop

bc_achou:
    move $v0, $s0           # Move o índice encontrado ($s0) para $v0 (retorno)
    j bc_fim                # Pula para o fim da função

bc_nao_achou:
    li $v0, -1              # Retorna -1 (erro: não encontrado)

bc_fim:
    lw $s1, 0($sp)          # Restaura $s1 da pilha
    lw $s0, 4($sp)          # Restaura $s0 da pilha
    lw $ra, 8($sp)          # Restaura $ra da pilha
    addi $sp, $sp, 12       # Libera os 12 bytes da pilha
    jr $ra                  # Retorna
    
# ==============================================================================
# ATOI (ASCII to Integer)
# ==============================================================================
atoi:
    li $v0, 0               # Inicializa o resultado ($v0) com 0
    move $t0, $a0           # Copia o ponteiro da string ($a0) para $t0
atoi_loop:
    lb $t1, 0($t0)          # Carrega o caractere atual em $t1
    blt $t1, 48, atoi_fim   # Se for < '0' (ASCII 48), pula para o fim
    bgt $t1, 57, atoi_fim   # Se for > '9' (ASCII 57), pula para o fim

    sub $t1, $t1, 48        # Converte o caractere ASCII para inteiro
    mul $v0, $v0, 10        # Multiplica o resultado atual por 10
    add $v0, $v0, $t1       # Soma o novo dígito ao resultado

    addi $t0, $t0, 1        # Avança o ponteiro da string
    j atoi_loop             # Volta ao início do loop
atoi_fim:
    jr $ra                  # Retorna
    
    # ==============================================================================
# RESGISTRO DE TRANSAÇÃO DE DÉBITO
# ==============================================================================
registra_transacao:
    # -- Salvando contexto --
    addi $sp, $sp, -12      # Aloca 12 bytes na pilha (para 3 registradores)
    sw $t0, 0($sp)          # Salva $t0 na pilha
    sw $t1, 4($sp)          # Salva $t1 na pilha
    sw $t2, 8($sp)          # Salva $t2 na pilha

    move $t0, $a0           # $t0 = índice (copia argumento $a0)
    move $t1, $a1           # $t1 = valor (copia argumento $a1)
    move $t2, $a2           # $t2 = tipo (copia argumento $a2)

    # 1. Verifica qtd de transações
    la $t3, HISTORICO_DEBITO_QTD # Carrega o endereço base do vetor de contadores
    mul $t4, $t0, 4         # Calcula o offset do cliente: $t4 = índice ($t0) * 4
    addu $t3, $t3, $t4      # Calcula o endereço final do contador deste cliente
    lw $t5, 0($t3)          # $t5 = Qtd atual -> Carrega o contador da memória
    li $t6, 50              # Carrega 50 (limite de transações)
    bge $t5, $t6, rt_fim    # Se QtdAtual >= 50, pula (não registra mais)

    # 2. Calcula endereço base
    mul $t6, $t0, 200       # Offset base do cliente: $t6 = índice ($t0) * 200 (50 trans * 4 bytes)
    mul $t7, $t5, 4         # Offset da transação: $t7 = QtdAtual ($t5) * 4 bytes
    add $t6, $t6, $t7       # $t6 = Offset total

    # 3. Salva o VALOR
    la $t8, HISTORICO_DEBITO_VALOR # Carrega o endereço base do vetor de valores
    addu $t8, $t8, $t6      # Calcula o endereço final: Base + OffsetTotal
    sw $t1, 0($t8)          # Salva o valor ($t1) na memória

    # 4. Salva o TIPO
    la $t8, HISTORICO_DEBITO_TIPO # Carrega o endereço base do vetor de tipos
    addu $t8, $t8, $t6      # Calcula o endereço final: Base + OffsetTotal
    sw $t2, 0($t8)          # Salva o tipo ($t2) na memória

    # 5. Incrementa contador
    addi $t5, $t5, 1        # Incrementa a quantidade de transações
    sw $t5, 0($t3)          # Salva o novo contador na memória

rt_fim:
    # -- Restaurando contexto --
    lw $t2, 8($sp)          # Restaura $t2 da pilha
    lw $t1, 4($sp)          # Restaura $t1 da pilha
    lw $t0, 0($sp)          # Restaura $t0 da pilha
    addi $sp, $sp, 12       # Libera os 12 bytes da pilha
    jr $ra                  # Retorna
    
# ==============================================================================
# REGISTRO DE TRANSAÇÃO DE CRÉDITO
# ==============================================================================
registra_credito:
    addi $sp, $sp, -12      # Aloca 12 bytes na pilha
    sw $t0, 0($sp)          # Salva $t0
    sw $t1, 4($sp)          # Salva $t1
    sw $t2, 8($sp)          # Salva $t2

    move $t0, $a0           # $t0 = índice (copia argumento $a0)
    move $t1, $a1           # $t1 = valor (copia argumento $a1)
    move $t2, $a2           # $t2 = tipo (copia argumento $a2)

    # 1. Verifica qtd de transações
    la $t3, HISTORICO_CREDITO_QTD # Carrega o endereço base do vetor de contadores
    mul $t4, $t0, 4         # Calcula o offset do cliente: $t4 = índice ($t0) * 4
    addu $t3, $t3, $t4      # Calcula o endereço final do contador deste cliente
    lw $t5, 0($t3)          # $t5 = Qtd atual -> Carrega o contador da memória
    li $t6, 50              # Carrega 50 (limite de transações)
    bge $t5, $t6, rc_fim    # Se QtdAtual >= 50, pula

    # 2. Calcula endereço base
    mul $t6, $t0, 200       # Offset base do cliente: $t6 = índice ($t0) * 200 (50 trans * 4 bytes)
    mul $t7, $t5, 4         # Offset da transação: $t7 = QtdAtual ($t5) * 4 bytes
    add $t6, $t6, $t7       # $t6 = Offset total

    # 3. Salva o VALOR
    la $t8, HISTORICO_CREDITO_VALOR # Carrega o endereço base do vetor de valores
    addu $t8, $t8, $t6      # Calcula o endereço final: Base + OffsetTotal
    sw $t1, 0($t8)          # Salva o valor ($t1) na memória

    # 4. Salva o TIPO
    la $t8, HISTORICO_CREDITO_TIPO # Carrega o endereço base do vetor de tipos
    addu $t8, $t8, $t6      # Calcula o endereço final: Base + OffsetTotal
    sw $t2, 0($t8)          # Salva o tipo ($t2) na memória

    # 5. Incrementa contador
    addi $t5, $t5, 1        # Incrementa a quantidade de transações
    sw $t5, 0($t3)          # Salva o novo contador na memória

rc_fim:
    lw $t2, 8($sp)          # Restaura $t2 da pilha
    lw $t1, 4($sp)          # Restaura $t1 da pilha
    lw $t0, 0($sp)          # Restaura $t0 da pilha
    addi $sp, $sp, 12       # Libera os 12 bytes da pilha
    jr $ra                  # Retorna
    
# ==============================================================================
# PRINT DINHEIRO
# ==============================================================================
print_dinheiro:
    addi $sp, $sp, -8       # Aloca 8 bytes na pilha
    sw $ra, 4($sp)          # Salva o endereço de retorno ($ra)
    sw $t0, 0($sp)          # Salva $t0
    
    move $t0, $a0           # Salva o valor original (em $a0) em $t0

    # 1. Imprime os Reais (Parte Inteira)
    li $t1, 100             # Carrega 100 para dividir
    div $t0, $t1            # Divide Valor ($t0) / 100 ($t1)
    mflo $a0                # $a0 = Quociente (Reais) -> Move o quociente para $a0
    li $v0, 1
    syscall                 # Imprime os Reais

    # 2. Imprime a Vírgula
    li $v0, 4
    la $a0, str_virgula
    syscall                 # Imprime ","

    # 3. Processa os Centavos (Resto)
    mfhi $t2                # $t2 = Resto (Centavos) -> Move o resto da divisão para $t2
    li $t3, 10              # Carrega 10 para comparar
    blt $t2, $t3, pd_add_zero # Se (Centavos < 10), pula para adicionar o '0'
    j pd_print_centavos     # Senão, pula direto para imprimir o valor

pd_add_zero:
    # Se for menor que 10, imprime um '0' na frente
    li $a0, '0'             # Carrega o caractere '0'
    li $v0, 11              # Carrega o código 11 (syscall: print_char)
    syscall                 # Imprime '0'

pd_print_centavos:
    # Imprime o valor dos centavos
    move $a0, $t2           # Move o valor dos centavos ($t2) para $a0
    li $v0, 1               # Carrega o código 1 (syscall: print_int)
    syscall                 # Imprime os Centavos

    # 4. Pula a linha no final
    li $v0, 4
    la $a0, str_newline
    syscall                 # Imprime "\n"

    lw $t0, 0($sp)          # Restaura $t0 da pilha
    lw $ra, 4($sp)          # Restaura $ra da pilha
    addi $sp, $sp, 8        # Libera os 8 bytes da pilha
    jr $ra                  # Retorna
