# ==============================================================================
# PROJETO 1 - ARQUITETURA E ORGANIZAÇÃO DE COMPUTADORES (UFRPE)
# Banco MIPS - Sistema Bancário
# Professor: Vitor Coutinho
# Alunos: Arthur Leonardo, Guilherme Guimarães, José Neto e Maria Eduarda
# ==============================================================================

.data
    # ==========================================================================
    # ÁREA DE DADOS GLOBAIS
    # ==========================================================================

    # --- Configurações do Sistema ---
    MAX_CLIENTES:   .word 50        # Número máximo de clientes permitidos
    QTD_CLIENTES:   .word 0         # Contador atual de clientes cadastrados

    # --- Banco de Dados dos Clientes (Vetores Paralelos) ---
    # Usamos .align 2 para garantir que os endereços de memória sejam múltiplos de 4.
    # Isso é importante para evitar erros de barramento (bus error) em algumas arquiteturas MIPS.
    .align 2
    CLIENTES_CPF:   .space 600      # 12 bytes (11 dígitos + \0) * 50 clientes
    .align 2
    CLIENTES_CONTA: .space 350      # 7 bytes (6 dígitos + \0) * 50 clientes
    .align 2
    CLIENTES_NOME:  .space 2500     # 50 bytes * 50 clientes
    .align 2
    CLIENTES_SALDO: .word 0:50      # Vetor de inteiros. Inicia com 50 zeros (4 bytes cada).
    .align 2
    CLIENTES_LIMITE:.word 150000:50 # Limite inicial por cliente (R$1500,00)
    .align 2
    CLIENTES_FATURA: .word 0:50     # Fatura do cliente com o banco
    
    # --- Histórico de Transações  ---
    .align 2
    HISTORICO_DEBITO_VALOR: .word 0:2500   # Guarda até 50 valores de transação por cliente
    HISTORICO_DEBITO_QTD:   .word 0:50     # Contador de quantas transações cada cliente fez
    .align 2
    HISTORICO_CREDITO_VALOR: .word 0:2500  # Guarda até 50 valores de transação por cliente
    HISTORICO_CREDITO_QTD:   .word 0:50    # Contador de quantas transações cada cliente fez

    # --- Buffers de Processamento de Texto ---
    buffer_cmd:     .space 256      # Armazena a linha de comando completa digitada pelo usuário
    arg0:           .space 64       # Armazena o primeiro token (o comando em si)
    arg1:           .space 64       # Armazena o primeiro argumento (ex: CPF)
    arg2:           .space 64       # Armazena o segundo argumento (ex: Conta)
    arg3:           .space 64       # Armazena o terceiro argumento (ex: Nome)
    buffer_resp:        .space 4        # Pequeno buffer para ler a resposta (s/n) na exclusão do histórico

    # --- Strings de Interface (Mensagens para o Usuário) ---
    str_banner:         .asciiz "\nSmartBank-shell>> "   # Prompt do terminal
    str_erro_cmd:       .asciiz "Comando invalido\n"
    str_sucesso_cad:    .asciiz "Cliente cadastrado com sucesso. Número da conta: "
    str_cheio:          .asciiz "Erro: Banco cheio.\n"
    str_hifen:          .asciiz "-"
    str_newline:        .asciiz "\n"
    str_virgula:        .asciiz ","
    str_erro_cliente:   .asciiz "Falha: cliente inexistente\n"
    str_extrato_header: .asciiz "\n--- Extrato de Debitos ---\n"
    str_ext_cred_header: .asciiz "\n--- Extrato de Credito ---\n"
    str_sem_transacoes: .asciiz "Nenhuma transacao encontrada.\n"
    str_sucesso_dep:    .asciiz "Deposito realizado. Novo saldo: R$ "
    str_sucesso_saque:  .asciiz "Saque realizado. Novo saldo: R$ "
    str_erro_saldo:     .asciiz "Falha: saldo insuficiente\n"
    str_sucesso_transf: .asciiz "Transferência realizada com sucesso.\n"
    str_erro_limite:    .asciiz "Falha: limite de credito insuficiente\n"
    str_sucesso_limite: .asciiz "Limite de credito alterado com sucesso para: R$ "
    str_sucesso_pagto:   .asciiz "Pagamento de fatura realizado: R$ "
    str_compra:          .asciiz "COMPRA: R$ "
    str_pagto:           .asciiz "PAGAMENTO:  R$ "
    str_confirma_fmt:   .asciiz "Tem certeza que deseja apagar o historico? (s/n): "
    str_sucesso_fmt:    .asciiz "Historico apagado com sucesso.\n"
    str_cancela_fmt:    .asciiz "Operacao cancelada.\n"
    str_sucesso_fechar: .asciiz "Conta fechada com sucesso.\n"
    str_erro_fechar:    .asciiz "Falha: conta ainda possui saldo de R$ "
    str_info_header:    .asciiz "\n--- Resumo da Conta ---\n"
    str_lbl_saldo:      .asciiz "Saldo em Conta: R$ "
    str_lbl_limite:     .asciiz "Limite Total:   R$ "
    str_lbl_fatura:     .asciiz "Fatura Atual:   R$ "
    str_lbl_disponivel: .asciiz "Disponivel Cred:R$ "
    str_sucesso_data:   .asciiz "Data e hora do sistema atualizadas.\n"
    str_data_atual:     .asciiz "Data/Hora atual: "
    str_barra:          .asciiz "/"
    str_dois_pontos:    .asciiz ":"
    str_espaco:         .asciiz " "
    
    # --- Comandos Reconhecidos pelo Sistema ---
    # Estas strings são usadas para comparar com o que o usuário digitou.
    cmd_cadastrar:      .asciiz "conta_cadastrar"
    cmd_debito_extrato: .asciiz "debito_extrato"
    cmd_credito_extrato: .asciiz "credito_extrato"
    cmd_depositar:      .asciiz "depositar"
    cmd_sacar:          .asciiz "sacar"
    cmd_transferir:     .asciiz "transferir_debito"
    cmd_transf_credito: .asciiz "transferir_credito"
    cmd_pagar_fatura:    .asciiz "pagar_fatura"
    cmd_alterar_limite: .asciiz "alterar_limite"
    cmd_conta_format:   .asciiz "conta_format"
    cmd_conta_fechar:   .asciiz "conta_fechar"
    cmd_conta_info:     .asciiz "conta_info"
    cmd_data_hora:      .asciiz "data_hora"
    cmd_sair:           .asciiz "sair"
    
    # --- RELÓGIO DO SISTEMA ---
    # Inicializa com uma data padrão (ex: 01/01/2025 12:00:00)
    DATA_DIA:   .word 1
    DATA_MES:   .word 1
    DATA_ANO:   .word 2025
    HORA_H:     .word 12
    HORA_M:     .word 0
    HORA_S:     .word 0
    
.text
.globl main

# ==============================================================================
# MAIN SHELL LOOP
# ==============================================================================
main:
shell_loop:
    li $v0, 4
    la $a0, str_banner
    syscall

    li $v0, 8
    la $a0, buffer_cmd
    li $a1, 256
    syscall

    la $a0, buffer_cmd
    jal parser_comandos

    la $a0, arg0
    la $a1, cmd_cadastrar
    jal strcmp
    beq $v0, 0, exec_cadastrar

    la $a0, arg0
    la $a1, cmd_sair
    jal strcmp
    beq $v0, 0, fim_programa
    
    la $a0, arg0
    la $a1, cmd_debito_extrato   # Verifica se o comando é "debito_extrato"
    jal strcmp
    beq $v0, 0, exec_debito_extrato  # Se for igual, pula para a função
    
    la $a0, arg0
    la $a1, cmd_credito_extrato
    jal strcmp
    beq $v0, 0, exec_credito_extrato
    
    la $a0, arg0
    la $a1, cmd_depositar
    jal strcmp
    beq $v0, 0, exec_depositar

    la $a0, arg0
    la $a1, cmd_sacar
    jal strcmp
    beq $v0, 0, exec_sacar
    
    la $a0, arg0
    la $a1, cmd_transferir
    jal strcmp
    beq $v0, 0, exec_transferir
    
    la $a0, arg0
    la $a1, cmd_transf_credito
    jal strcmp
    beq $v0, 0, exec_transf_credito
    
    la $a0, arg0
    la $a1, cmd_conta_info
    jal strcmp
    beq $v0, 0, exec_conta_info
    
    la $a0, arg0                	# Carrega o comando digitado pelo usuário
    la $a1, cmd_alterar_limite 		# Carrega a string modelo "alterar_limite"
    jal strcmp                  	# Compara as duas strings
    beq $v0, 0, exec_alterar_limite 	# Se forem iguais, pula para a função de execução

    la $a0, arg0
    la $a1, cmd_pagar_fatura
    jal strcmp
    beq $v0, 0, exec_pagar_fatura

    la $a0, arg0
    la $a1, cmd_conta_format
    jal strcmp
    beq $v0, 0, exec_conta_format

    la $a0, arg0
    la $a1, cmd_conta_fechar
    jal strcmp
    beq $v0, 0, exec_conta_fechar

    la $a0, arg0
    la $a1, cmd_data_hora
    jal strcmp
    beq $v0, 0, exec_data_hora

    li $v0, 4
    la $a0, str_erro_cmd
    syscall
    j shell_loop

# ==============================================================================
# COMANDO: CADASTRAR
#Formato: conta_cadastrar-<CPF>-<conta>-<nome>
# ==============================================================================
exec_cadastrar:
    addi $sp, $sp, -8       # Abre espaço para 2 itens na pilha
    sw $ra, 4($sp)          # Salva $ra
    sw $s1, 0($sp)          # Salva $s1

    lw $t0, QTD_CLIENTES
    lw $t1, MAX_CLIENTES
    bge $t0, $t1, cad_erro_cheio

    # Calcula DV
    la $a0, arg2
    jal calcula_dv
    move $s0, $v0           # $s0 guarda o DV

    # --- SALVANDO NA MEMÓRIA ---
    lw $s1, QTD_CLIENTES    # USA $s1 AGORA, NÃO MAIS $t0

    # 1. CPF
    la $a0, CLIENTES_CPF
    li $t2, 12
    mul $t1, $s1, $t2       # Usa $s1 para calcular offset
    addu $a0, $a0, $t1
    la $a1, arg1
    jal strcpy

    # 2. Conta
    la $a0, CLIENTES_CONTA
    li $t2, 7
    mul $t1, $s1, $t2       # Usa $s1 aqui também (ele não foi alterado pelo strcpy)
    addu $a0, $a0, $t1
    la $a1, arg2
    jal strcpy

    # 3. Nome
    la $a0, CLIENTES_NOME
    li $t2, 50
    mul $t1, $s1, $t2
    addu $a0, $a0, $t1
    la $a1, arg3
    jal strcpy

    # Incrementa contador
    addi $s1, $s1, 1
    sw $s1, QTD_CLIENTES

    # Feedback
    li $v0, 4
    la $a0, str_sucesso_cad
    syscall
    la $a0, arg2
    syscall
    la $a0, str_hifen
    syscall
    
    li $t2, 10
    beq $s0, $t2, cad_print_x
    move $a0, $s0
    li $v0, 1
    syscall
    j cad_fim

cad_print_x:
    li $a0, 'X'
    li $v0, 11
    syscall

cad_fim:
    lw $s1, 0($sp)          # Restaura $s1 original
    lw $ra, 4($sp)          # Restaura $ra
    addi $sp, $sp, 8        # Fecha a pilha
    j shell_loop

cad_erro_cheio:
    li $v0, 4
    la $a0, str_cheio
    syscall
    j cad_fim
    
    # ==============================================================================
# COMANDO: DEPOSITAR
# Formato: depositar-<Conta>-<Valor(centavos)>
# ==============================================================================
exec_depositar:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # 1. Busca o cliente pela conta (arg1)
    la $a0, arg1
    jal busca_cliente
    move $t0, $v0           # $t0 = índice do cliente
    li $t1, -1
    beq $t0, $t1, dep_erro_cli

    # 2. Converte o valor do depósito (arg2) para inteiro
    move $s0, $t0           # Salva índice do cliente em $s0 (seguro)
    la $a0, arg2
    jal atoi
    move $s1, $v0           # $s1 = valor a depositar (inteiro)

    # 3. Atualiza o saldo
    la $a0, CLIENTES_SALDO  # Endereço base do vetor de saldos
    mul $t1, $s0, 4         # Offset = índice * 4 bytes (word)
    addu $a0, $a0, $t1      # Endereço exato do saldo deste cliente
    lw $t2, 0($a0)          # Carrega saldo atual
    add $t2, $t2, $s1       # Soma: saldo atual + depósito
    sw $t2, 0($a0)          # Salva novo saldo na memória
    
    # 4. Registra no extrato
    move $a0, $s0           # Passa o índice do cliente ($s0)
    move $a1, $s1           # Passa o valor depositado ($s1)
    jal registra_transacao  # Chama a função que cria o histórico

    # 5. Feedback
    li $v0, 4
    la $a0, str_sucesso_dep
    syscall

    # Truque rápido para imprimir centavos: dividir por 100 para os reais
    li $t3, 100
    div $t2, $t3
    mflo $a0                # Parte inteira (reais)
    li $v0, 1
    syscall
    
    li $v0, 4
    la $a0, str_virgula     # Imprime a vírgula
    syscall

    mfhi $a0                # Resto da divisão (centavos)
    li $v0, 1
    syscall

    li $v0, 4
    la $a0, str_newline
    syscall
    j dep_fim

dep_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Reusando a string de erro do extrato
    syscall

dep_fim:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j shell_loop
    
# ==============================================================================
# COMANDO: SACAR
# Formato: sacar-<Conta>-<Valor(centavos)>
# ==============================================================================
exec_sacar:
    addi $sp, $sp, -4       # Abre espaço na pilha para 1 palavra (4 bytes)
    sw $ra, 0($sp)          # Salva o endereço de retorno ($ra) na pilha

    # 1. Busca o cliente
    # O número da conta foi passado como segundo argumento (arg1) pelo parser.
    la $a0, arg1            # Carrega o endereço da string da conta em $a0
    jal busca_cliente       # Chama a função auxiliar para encontrar o índice do cliente
    move $t0, $v0           # Move o resultado (índice ou -1) para $t0 temporariamente
    li $t1, -1              # Carrega o valor -1 em $t1 para comparação
    beq $t0, $t1, saque_erro_cli # Se índice == -1, cliente não encontrado. Pula para erro.

    # 2. Converte o valor do saque
    # O valor do saque está em arg2 como texto. Precisamos converter para número inteiro.
    move $s0, $t0           # Salva o índice do cliente em $s0 (registrador seguro)
    la $a0, arg2            # Carrega o endereço da string do valor em $a0
    jal atoi                # Chama função auxiliar ASCII to Integer
    move $s1, $v0           # Salva o valor numérico do saque em $s1 (registrador seguro)

    # 3. Verificação de saldo
    # Precisamos saber quanto dinheiro o cliente tem antes de deixar ele sacar.
    la $a0, CLIENTES_SALDO  # Carrega o endereço base do vetor de saldos
    mul $t1, $s0, 4         # Calcula o deslocamento: índice do cliente * 4 bytes (tamanho de uma word)
    addu $a0, $a0, $t1      # Soma base + deslocamento para ter o endereço exato do saldo deste cliente
    lw $t2, 0($a0)          # Carrega o valor do saldo atual da memória para $t2

    # Compara: se Saldo Atual ($t2) for menor que Valor Saque ($s1), não pode sacar.
    blt $t2, $s1, saque_erro_saldo # Desvia para mensagem de erro se saldo for insuficiente

    # 4. Realiza o saque
    sub $t2, $t2, $s1       # Subtrai o valor do saque do saldo atual ($t2 = $t2 - $s1)
    sw $t2, 0($a0)          # Salva o novo saldo atualizado de volta na memória
    
    # 5. Registra no extrato
    move $a0, $s0           # Índice do cliente
    neg $a1, $s1            # INVERTE o sinal do valor (vira negativo)
    jal registra_transacao

    # 6. Feedback para o usuário
    # Imprime mensagem de sucesso e o novo saldo.
    li $v0, 4               # Syscall 4: print_string
    la $a0, str_sucesso_saque # Carrega mensagem "Saque realizado..."
    syscall

    # -- Formatação simples de moeda (R$ Reais,Centavos) --
    li $t3, 100             # Carrega divisor 100 para separar reais de centavos
    div $t2, $t3            # Divide o saldo total (em centavos) por 100
    mflo $a0                # Move o quociente (parte inteira, os reais) para $a0
    li $v0, 1               # Syscall 1: print_int
    syscall                 # Imprime os reais

    li $v0, 4               # Syscall 4: print_string
    la $a0, str_virgula     # Imprime a vírgula separadora
    syscall

    mfhi $a0                # Move o resto da divisão (os centavos) para $a0
    li $v0, 1               # Syscall 1: print_int
    syscall                 # Imprime os centavos

    li $v0, 4               # Syscall 4: print_string
    la $a0, str_newline     # Pula uma linha para organização do terminal
    syscall
    j saque_fim             # Pula para o fim da função (evita cair nos blocos de erro abaixo)

# --- BLOCOS DE TRATAMENTO DE ERRO ---
saque_erro_saldo:
    li $v0, 4               # Syscall 4: print_string
    la $a0, str_erro_saldo  # Carrega mensagem "Saldo insuficiente"
    syscall
    j saque_fim             # Vai para o fim

saque_erro_cli:
    li $v0, 4               # Syscall 4: print_string
    la $a0, str_erro_cliente # Carrega mensagem "Cliente inexistente"
    syscall

# --- FINALIZAÇÃO DA FUNÇÃO ---
saque_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno original da pilha
    addi $sp, $sp, 4        # Libera o espaço usado na pilha
    j shell_loop            # Retorna para o loop principal do terminal
    
# ==============================================================================
# COMANDO: EXTRATO DE DÉBITO
#formato: debito_extrato-<conta>
# ==============================================================================
exec_debito_extrato:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # 1. Busca cliente pela conta (arg1)
    la $a0, arg1
    jal busca_cliente
    move $s0, $v0           # $s0 = índice do cliente
    li $t1, -1
    beq $s0, $t1, extrato_erro_cliente

    # 2. Imprime Cabeçalho
    li $v0, 4
    la $a0, str_extrato_header
    syscall

    # 3. Descobre QUANTAS transações esse cliente tem
    la $a0, HISTORICO_DEBITO_QTD
    mul $t1, $s0, 4         # Offset = índice * 4
    addu $a0, $a0, $t1      # Endereço do contador
    lw $s1, 0($a0)          # $s1 = Quantidade total de transações

    # Se qtd == 0, imprime mensagem "Nenhuma transação"
    beq $s1, $zero, extrato_vazio

    # 4. LOOP PARA IMPRIMIR CADA TRANSAÇÃO
    li $s2, 0               # $s2 = Contador do loop (começa em 0)

ext_loop:
    bge $s2, $s1, ext_fim_loop # Se contador >= total, terminou

    # -- Calcula endereço da transação atual --
    # Base do cliente = ÍndiceCliente * 200 (50 transações * 4 bytes)
    mul $t2, $s0, 200
    # Offset da transação = ContadorLoop * 4
    mul $t3, $s2, 4
    add $t2, $t2, $t3       # Offset total
    la $t4, HISTORICO_DEBITO_VALOR
    addu $t4, $t4, $t2      # Endereço final
    lw $s3, 0($t4)          # $s3 = Valor da transação

    # -- Verifica se é Saque (negativo) ou Depósito (positivo) --
    blt $s3, $zero, ext_print_saque

    # [CASO DEPÓSITO]
    li $v0, 4
    la $a0, str_sucesso_dep # Reusa string "Deposito... R$ " (gambiarra útil)
    syscall
    move $a0, $s3           # Valor para imprimir
    jal print_dinheiro      # Chama função auxiliar para imprimir R$ XX,XX
    j ext_proximo

ext_print_saque:
    # [CASO SAQUE]
    li $v0, 4
    la $a0, str_sucesso_saque # Reusa string "Saque... R$ "
    syscall
    neg $a0, $s3            # Inverte o sinal para imprimir positivo (ex: -50 vira 50)
    jal print_dinheiro

ext_proximo:
    addi $s2, $s2, 1        # Incrementa contador do loop
    j ext_loop

ext_fim_loop:
    j extrato_fim

extrato_vazio:
    li $v0, 4
    la $a0, str_sem_transacoes
    syscall
    j extrato_fim

extrato_erro_cliente:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

extrato_fim:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j shell_loop
    
# ==============================================================================
# COMANDO: EXTRATO DE CRÉDITO
# Formato: credito_extrato-<conta>
# Objetivo: Listar compras (negativo) e pagamentos de fatura (positivo).
# ==============================================================================
exec_credito_extrato:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # 1. Busca cliente
    la $a0, arg1
    jal busca_cliente
    move $s0, $v0
    li $t1, -1
    beq $s0, $t1, extc_erro_cli

    # 2. Imprime Cabeçalho
    li $v0, 4
    la $a0, str_ext_cred_header
    syscall

    # 3. Lê quantidade de transações
    la $a0, HISTORICO_CREDITO_QTD
    mul $t1, $s0, 4
    addu $a0, $a0, $t1
    lw $s1, 0($a0)          # $s1 = Quantidade total

    beq $s1, $zero, extc_vazio

    # 4. Loop de impressão
    li $s2, 0               # Contador do loop
extc_loop:
    bge $s2, $s1, extc_fim_loop

    mul $t2, $s0, 200       # Base do cliente
    mul $t3, $s2, 4         # Offset da transação
    add $t2, $t2, $t3
    la $t4, HISTORICO_CREDITO_VALOR
    addu $t4, $t4, $t2
    lw $s3, 0($t4)          # $s3 = Valor da transação

    # Se valor < 0, é COMPRA. Se valor > 0, é PAGAMENTO.
    blt $s3, $zero, extc_print_compra

    # [PAGAMENTO]
    li $v0, 4
    la $a0, str_pagto
    syscall
    move $a0, $s3
    jal print_dinheiro
    j extc_proximo

extc_print_compra:
    # [COMPRA]
    li $v0, 4
    la $a0, str_compra
    syscall
    neg $a0, $s3            # Inverte para mostrar positivo
    jal print_dinheiro

extc_proximo:
    addi $s2, $s2, 1
    j extc_loop

extc_fim_loop:
    j extc_fim

extc_vazio:
    li $v0, 4
    la $a0, str_sem_transacoes # Reusa string genérica
    syscall
    j extc_fim

extc_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

extc_fim:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j shell_loop
    
# ==============================================================================
# COMANDO: TRANSFERIR (DÉBITO)
# Formato: transferir_debito-<ContaDestino>-<ContaOrigem>-<Valor>
# ==============================================================================
exec_transferir:
    addi $sp, $sp, -20      # Salva muitos registradores para não perder dados
    sw $ra, 16($sp)
    sw $s0, 12($sp)         # Índice Origem
    sw $s1, 8($sp)          # Valor Transferência
    sw $s2, 4($sp)          # Índice Destino
    sw $s3, 0($sp)          # Temp para saldos

    # 1. BUSCA CONTA ORIGEM (arg2)
    la $a0, arg2
    jal busca_cliente
    move $s0, $v0           # $s0 = Índice Origem
    li $t0, -1
    beq $s0, $t0, transf_erro_cli

    # 2. BUSCA CONTA DESTINO (arg1)
    la $a0, arg1
    jal busca_cliente
    move $s2, $v0           # $s2 = Índice Destino
    li $t0, -1
    beq $s2, $t0, transf_erro_cli

    # 3. CONVERTE VALOR (arg3)
    la $a0, arg3
    jal atoi
    move $s1, $v0           # $s1 = Valor da transferência

    # 4. VERIFICA SALDO DA ORIGEM
    la $a0, CLIENTES_SALDO
    mul $t1, $s0, 4         # Offset Origem
    addu $t2, $a0, $t1      # Endereço Saldo Origem
    lw $s3, 0($t2)          # $s3 = Saldo Atual da Origem

    blt $s3, $s1, transf_erro_saldo # Se saldo < valor, erro!

    # 5. REALIZA A TRANSFERÊNCIA
    
    # 5a. Debita da Origem
    sub $s3, $s3, $s1       # SaldoOrigem - Valor
    sw $s3, 0($t2)          # Salva novo saldo origem

    # 5b. Credita no Destino
    la $a0, CLIENTES_SALDO
    mul $t1, $s2, 4         # Offset Destino
    addu $t3, $a0, $t1      # Endereço Saldo Destino
    lw $s3, 0($t3)          # Carrega saldo atual do destino
    add $s3, $s3, $s1       # SaldoDestino + Valor
    sw $s3, 0($t3)          # Salva novo saldo destino

    # 6. REGISTRA NO EXTRATO DE AMBOS
    # Registra Saque na Origem
    move $a0, $s0
    neg $a1, $s1
    jal registra_transacao

    # Registra Depósito no Destino
    move $a0, $s2
    move $a1, $s1
    jal registra_transacao

    # 7. Feedback de Sucesso
    li $v0, 4
    la $a0, str_sucesso_transf
    syscall
    j transf_fim

transf_erro_saldo:
    li $v0, 4
    la $a0, str_erro_saldo
    syscall
    j transf_fim

transf_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

transf_fim:
    # Restaura tudo antes de sair
    lw $s3, 0($sp)
    lw $s2, 4($sp)
    lw $s1, 8($sp)
    lw $s0, 12($sp)
    lw $ra, 16($sp)
    addi $sp, $sp, 20
    j shell_loop
    
# ==============================================================================
# COMANDO: TRANSFERIR (CRÉDITO)
# Formato: transferir_credito-<ContaDestino>-<ContaOrigem>-<Valor>
# ==============================================================================
exec_transf_credito:
    addi $sp, $sp, -24      # Aumentei o espaço na pilha
    sw $ra, 20($sp)
    sw $s0, 16($sp)         # Índice Origem
    sw $s1, 12($sp)         # Valor Transferência
    sw $s2, 8($sp)          # Índice Destino
    sw $s3, 4($sp)          # Limite Origem
    sw $s4, 0($sp)          # Fatura Origem

    # 1. Busca Origem (arg2)
    la $a0, arg2
    jal busca_cliente
    move $s0, $v0
    li $t0, -1
    beq $s0, $t0, tc_erro_cli


    # 2. Busca Destino (arg1)
    la $a0, arg1
    jal busca_cliente
    move $s2, $v0
    li $t0, -1
    beq $s2, $t0, tc_erro_cli

    # 3. Converte Valor (arg3)
    la $a0, arg3
    jal atoi
    move $s1, $v0

    # 4. VERIFICA LIMITE DISPONÍVEL
    # Carrega Limite Total
    la $a0, CLIENTES_LIMITE
    mul $t1, $s0, 4
    addu $a0, $a0, $t1
    lw $s3, 0($a0)          # $s3 = Limite Total

    # Carrega Fatura Atual
    la $a0, CLIENTES_FATURA
    # (Offset $t1 já está calculado corretamente acima)
    addu $a0, $a0, $t1
    lw $s4, 0($a0)          # $s4 = Fatura Atual

    # Calcula Disponível: (Limite - Fatura)
    sub $t2, $s3, $s4       # $t2 = Disponível

    # Se Disponível < Valor Solicitado, erro!
    blt $t2, $s1, tc_erro_limite

    # 5. REALIZA A TRANSFERÊNCIA
    # 5a. Aumenta a Fatura da Origem
    add $s4, $s4, $s1       # Nova Fatura = Fatura Atual + Valor
    la $a0, CLIENTES_FATURA
    mul $t1, $s0, 4
    addu $a0, $a0, $t1
    sw $s4, 0($a0)          # Salva nova fatura

    # 5b. Aumenta o Saldo do Destino
    la $a0, CLIENTES_SALDO
    mul $t1, $s2, 4
    addu $a0, $a0, $t1
    lw $t3, 0($a0)          # Saldo atual destino
    add $t3, $t3, $s1       # + Valor
    sw $t3, 0($a0)          # Salva novo saldo destino

    # 6. REGISTRA NO HISTÓRICO
    # Na origem, registra como uso de CRÉDITO (negativo para indicar gasto)
    move $a0, $s0
    neg $a1, $s1
    jal registra_credito

    # No destino, é um depósito normal em conta corrente
    move $a0, $s2
    move $a1, $s1
    jal registra_transacao

    # Feedback
    li $v0, 4
    la $a0, str_sucesso_transf # Reusa mensagem de transferência
    syscall
    j tc_fim

tc_erro_limite:
    li $v0, 4
    la $a0, str_erro_limite
    syscall
    j tc_fim

tc_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

tc_fim:
    lw $s4, 0($sp)
    lw $s3, 4($sp)
    lw $s2, 8($sp)
    lw $s1, 12($sp)
    lw $s0, 16($sp)
    lw $ra, 20($sp)
    addi $sp, $sp, 24
    j shell_loop
    
# ==============================================================================
# COMANDO: PAGAR FATURA
# Formato: pagar_fatura-<Conta>-<Valor>-<Modo>
# Modo de pagamento: 'S' = Tira do saldo da Conta, 'E' = Externo (dinheiro físico)
# ==============================================================================
exec_pagar_fatura:
    addi $sp, $sp, -16
    sw $ra, 12($sp)
    sw $s0, 8($sp)          # Índice Cliente
    sw $s1, 4($sp)          # Valor Pagamento
    sw $s2, 0($sp)          # Endereço Fatura

    # 1. Busca cliente
    la $a0, arg1
    jal busca_cliente
    move $s0, $v0
    li $t1, -1
    beq $s0, $t1, pgto_erro_cli

    # 2. Converte valor
    la $a0, arg2
    jal atoi
    move $s1, $v0

    # 3. Verifica Modo de Pagamento (arg3)
    la $t0, arg3
    lb $t1, 0($t0)          # Lê o primeiro caractere de arg3 ('S' ou 'E')
    li $t2, 'S'
    beq $t1, $t2, pgto_modo_saldo
    li $t2, 's'             # Aceita 's' minúsculo também
    beq $t1, $t2, pgto_modo_saldo

    # --- MODO EXTERNO (E) ---
    # Só precisa reduzir a fatura, não mexe no saldo da conta.
    j pgto_efetiva

pgto_modo_saldo:
    # --- MODO SALDO (S) ---
    # Precisa verificar se tem saldo suficiente na conta corrente.
    la $a0, CLIENTES_SALDO
    mul $t1, $s0, 4
    addu $a0, $a0, $t1      # Endereço do saldo
    lw $t2, 0($a0)          # Saldo atual
    
    blt $t2, $s1, pgto_erro_saldo # Se Saldo < Valor, erro!

    # Se tem saldo, debita dele
    sub $t2, $t2, $s1
    sw $t2, 0($a0)          # Atualiza saldo na memória

    # Registra o débito no extrato da conta corrente também
    move $a0, $s0
    neg $a1, $s1
    jal registra_transacao

pgto_efetiva:
    # 4. REDUZ A FATURA
    la $a0, CLIENTES_FATURA
    mul $t1, $s0, 4
    addu $s2, $a0, $t1      # Guarda endereço da fatura em $s2
    lw $t2, 0($s2)          # Fatura atual

    # (Opcional: Verificar se está pagando mais do que deve. Por enquanto, deixamos passar)
    sub $t2, $t2, $s1       # Fatura = Fatura - Pagamento
    sw $t2, 0($s2)          # Salva nova fatura

    # 5. REGISTRA NO HISTÓRICO DE CRÉDITO (Valor positivo = pagamento)
    move $a0, $s0
    move $a1, $s1
    jal registra_credito

    # Feedback
    li $v0, 4
    la $a0, str_sucesso_pagto
    syscall
    move $a0, $s1
    jal print_dinheiro
    j pgto_fim

pgto_erro_saldo:
    li $v0, 4
    la $a0, str_erro_saldo  # Reusa string de erro de saldo
    syscall
    j pgto_fim

pgto_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

pgto_fim:
    lw $s2, 0($sp)
    lw $s1, 4($sp)
    lw $s0, 8($sp)
    lw $ra, 12($sp)
    addi $sp, $sp, 16
    j shell_loop
    
# ==============================================================================
# COMANDO: INFORMAÇÕES DA CONTA
# Formato: conta_info-<Conta>
# Objetivo: Mostrar um resumo rápido de saldo, limite e fatura.
# ==============================================================================
exec_conta_info:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # 1. BUSCA O CLIENTE
    la $a0, arg1
    jal busca_cliente
    move $s0, $v0
    li $t1, -1
    beq $s0, $t1, info_erro_cli

    # 2. IMPRIME CABEÇALHO
    li $v0, 4
    la $a0, str_info_header
    syscall

    # 3. MOSTRA SALDO
    li $v0, 4
    la $a0, str_lbl_saldo
    syscall
    la $a0, CLIENTES_SALDO
    mul $t1, $s0, 4
    addu $a0, $a0, $t1
    lw $a0, 0($a0)          # Carrega o saldo diretamente para $a0
    jal print_dinheiro

    # 4. MOSTRA LIMITE TOTAL
    li $v0, 4
    la $a0, str_lbl_limite
    syscall
    la $a0, CLIENTES_LIMITE
    # (Offset $t1 ainda é válido aqui, pois não mudamos $s0)
    addu $a0, $a0, $t1
    lw $s1, 0($a0)          # $s1 = Limite Total
    move $a0, $s1
    jal print_dinheiro

    # 5. MOSTRA FATURA ATUAL
    li $v0, 4
    la $a0, str_lbl_fatura
    syscall
    la $a0, CLIENTES_FATURA
    mul $t1, $s0, 4
    addu $a0, $a0, $t1
    lw $s2, 0($a0)          # $s2 = Fatura Atual
    move $a0, $s2
    jal print_dinheiro

    # 6. MOSTRA LIMITE DISPONÍVEL (Limite - Fatura)
    li $v0, 4
    la $a0, str_lbl_disponivel
    syscall
    sub $a0, $s1, $s2       # Disponível = Limite ($s1) - Fatura ($s2)
    jal print_dinheiro

    j info_fim

info_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

info_fim:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j shell_loop

# ==============================================================================
# COMANDO: ALTERAR LIMITE
# Formato: alterar_limite-<Conta>-<NovoLimite(centavos)>
# Objetivo: Atualizar o valor do limite de crédito de um cliente.
# ==============================================================================
exec_alterar_limite:
    addi $sp, $sp, -4       # Abre espaço na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno

    # 1. BUSCA O CLIENTE
    # O número da conta está em arg1. Chamamos a função auxiliar para achar o índice.
    la $a0, arg1
    jal busca_cliente
    move $t0, $v0           # $t0 = índice do cliente encontrado (ou -1 se não achou)
    li $t1, -1
    beq $t0, $t1, lim_erro_cli # Se índice for -1, exibe erro de cliente inexistente

    # 2. CONVERTE O NOVO LIMITE
    # O novo valor está em arg2 como texto. Aqui converte para número inteiro.
    move $s0, $t0           # Salva o índice do cliente em $s0 (registrador seguro)
    la $a0, arg2            # Carrega o endereço da string do valor
    jal atoi                # Chama a função de conversão ASCII para Inteiro
    move $s1, $v0           # $s1 = novo limite (em centavos)

    # 3. ATUALIZA O LIMITE NA MEMÓRIA
    la $a0, CLIENTES_LIMITE # Carrega o endereço base do vetor de limites de crédito
    mul $t1, $s0, 4         # Calcula o deslocamento: índice * 4 bytes
    addu $a0, $a0, $t1      # Endereço final = Base + Deslocamento
    sw $s1, 0($a0)          # Salva o novo limite na posição correta da memória

    # 4. FEEDBACK PARA O USUÁRIO
    li $v0, 4               # Syscall para imprimir string
    la $a0, str_sucesso_limite # Imprime "Limite de credito alterado..."
    syscall

    # Usa a função auxiliar para imprimir o valor formatado (R$ XX,XX)
    move $a0, $s1           # Passa o novo limite como argumento
    jal print_dinheiro      # Chama a função de impressão formatada

    j lim_fim               # Pula para o fim da função

lim_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente # Imprime mensagem de erro se cliente não foi achado
    syscall

lim_fim:
    lw $ra, 0($sp)          # Restaura o endereço de retorno original
    addi $sp, $sp, 4        # Libera a pilha
    j shell_loop            # Volta para o loop principal do terminal

# ==============================================================================
# COMANDO: FORMATAR CONTA
# Formato: conta_format-<Conta>
# Objetivo: Apagar o histórico de transações de um cliente.
# ==============================================================================
exec_conta_format:
    addi $sp, $sp, -4       # Abre espaço na pilha
    sw $ra, 0($sp)          # Salva o endereço de retorno

    # 1. BUSCA O CLIENTE
    la $a0, arg1            # O número da conta está em arg1
    jal busca_cliente
    move $s0, $v0           # $s0 = índice do cliente
    li $t1, -1
    beq $s0, $t1, fmt_erro_cli # Se não achou, exibe erro

    # 2. PEDE CONFIRMAÇÃO
    li $v0, 4
    la $a0, str_confirma_fmt # "Tem certeza...? (s/n): "
    syscall

    # Lê a resposta do usuário (s ou n)
    li $v0, 8               # Syscall para ler string
    la $a0, buffer_resp     # Buffer onde salvar a resposta
    li $a1, 4               # Tamanho máximo
    syscall

    # Verifica se a resposta foi 's' (sim)
    la $t0, buffer_resp
    lb $t1, 0($t0)          # Lê o primeiro caractere da resposta
    li $t2, 's'             # Carrega o caractere 's' para comparar
    bne $t1, $t2, fmt_cancela # Se não for 's', cancela a operação

    # 3. EXECUTA A FORMATAÇÃO (Zera o contador de transações)
    la $a0, HISTORICO_DEBITO_QTD # Endereço base do vetor de quantidades
    mul $t1, $s0, 4         # Offset = índice do cliente * 4
    addu $a0, $a0, $t1      # Endereço exato do contador deste cliente
    sw $zero, 0($a0)        # Salva 0 na memória, efetivamente apagando o histórico

    # Feedback de sucesso
    li $v0, 4
    la $a0, str_sucesso_fmt
    syscall
    j fmt_fim

fmt_cancela:
    li $v0, 4
    la $a0, str_cancela_fmt
    syscall
    j fmt_fim

fmt_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

fmt_fim:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j shell_loop
    
# ==============================================================================
# COMANDO: FECHAR CONTA
# Formato: conta_fechar-<Conta>
# Objetivo: Encerrar uma conta se ela não tiver saldo nem dívidas.
# ==============================================================================
exec_conta_fechar:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # 1. BUSCA O CLIENTE
    la $a0, arg1
    jal busca_cliente
    move $t0, $v0
    li $t1, -1
    beq $t0, $t1, fechar_erro_cli

    # 2. VERIFICA SE TEM SALDO (Deve ser zero para fechar)
    move $s0, $t0           # $s0 = índice do cliente
    la $a0, CLIENTES_SALDO
    mul $t1, $s0, 4
    addu $a0, $a0, $t1
    lw $s1, 0($a0)          # $s1 = Saldo atual

    bne $s1, $zero, fechar_erro_saldo # Se saldo != 0, não pode fechar!

    # 3. "APAGA" O CLIENTE
    # Truque: Vamos marcar a conta dele como inativa colocando um '*' no início.
    # Isso fará com que a função 'busca_cliente' não a encontre mais.
    la $a0, CLIENTES_CONTA
    mul $t1, $s0, 7
    addu $a0, $a0, $t1
    li $t2, '*'             # Caractere marcador de conta fechada
    sb $t2, 0($a0)          # Sobrescreve o primeiro dígito da conta


    # 4. FEEDBACK DE SUCESSO
    li $v0, 4
    la $a0, str_sucesso_fechar
    syscall
    j fechar_fim

fechar_erro_saldo:
    li $v0, 4
    la $a0, str_erro_fechar
    syscall
    move $a0, $s1           # Imprime o saldo que ainda resta
    jal print_dinheiro
    j fechar_fim

fechar_erro_cli:
    li $v0, 4
    la $a0, str_erro_cliente
    syscall

fechar_fim:
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j shell_loop
    
# ==============================================================================
# COMANDO: AJUSTAR DATA E HORA
# Formato: data_hora-<DDMMAAAA>-<HHMMSS>
# ==============================================================================
exec_data_hora:
    addi $sp, $sp, -4
    sw $ra, 0($sp)

    # 1. Converte Data (arg1) para inteiro
    la $a0, arg1
    jal atoi
    move $t0, $v0           # $t0 = DDMMAAAA (ex: 10112025)

    # 2. Extrai Dia, Mês, Ano usando divisões
    # Ano = DDMMAAAA % 10000
    li $t1, 10000
    div $t0, $t1
    mfhi $t2                # $t2 = AAAA (2025)
    sw $t2, DATA_ANO
    mflo $t0                # $t0 = DDMM (1011)

    # Mês = DDMM % 100
    li $t1, 100
    div $t0, $t1
    mfhi $t2                # $t2 = MM (11)
    sw $t2, DATA_MES
    mflo $t2                # $t2 = DD (10)
    sw $t2, DATA_DIA

    # 3. Converte Hora (arg2) para inteiro
    la $a0, arg2
    jal atoi
    move $t0, $v0           # $t0 = HHMMSS (ex: 143000)

    # 4. Extrai Hora, Minuto, Segundo
    # Segundo = HHMMSS % 100
    li $t1, 100
    div $t0, $t1
    mfhi $t2                # $t2 = SS (00)
    sw $t2, HORA_S
    mflo $t0                # $t0 = HHMM (1430)

    # Minuto = HHMM % 100
    div $t0, $t1
    mfhi $t2                # $t2 = MM (30)
    sw $t2, HORA_M
    mflo $t2                # $t2 = HH (14)
    sw $t2, HORA_H

    # 5. Feedback
    li $v0, 4
    la $a0, str_sucesso_data
    syscall

    lw $ra, 0($sp)
    addi $sp, $sp, 4
    j shell_loop

# ==============================================================================
# PARSER E HELPERS
# ==============================================================================
parser_comandos:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    move $t9, $a0
    la $a0, arg0
    move $a1, $t9
    li $a2, '-'
    jal copy_token
    move $t9, $v0
    la $a0, arg1
    move $a1, $t9
    li $a2, '-'
    jal copy_token
    move $t9, $v0
    la $a0, arg2
    move $a1, $t9
    li $a2, '-'
    jal copy_token
    move $t9, $v0
    la $a0, arg3
    move $a1, $t9
    li $a2, 10
    jal copy_token
    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra

copy_token:
    move $t8, $a0
    move $t7, $a1
ct_loop:
    lb $t6, 0($t7)
    beq $t6, $zero, ct_fim
    beq $t6, 10, ct_fim
    beq $t6, 13, ct_fim
    beq $t6, $a2, ct_achou_delim
    sb $t6, 0($t8)
    addi $t8, $t8, 1
    addi $t7, $t7, 1
    j ct_loop
ct_achou_delim:
    sb $zero, 0($t8)
    addi $v0, $t7, 1
    jr $ra
ct_fim:
    sb $zero, 0($t8)
    move $v0, $t7
    jr $ra

calcula_dv:
    move $t0, $a0
    li $t7, 0
    li $t3, 7
    li $t4, 0
cdv_loop:
    lb $t1, 0($t0)
    beq $t1, $zero, cdv_calc_final
    subu $t1, $t1, 48
    mult $t1, $t3
    mflo $t1
    addu $t7, $t7, $t1
    addi $t0, $t0, 1
    addi $t3, $t3, -1
    addi $t4, $t4, 1
    blt $t4, 6, cdv_loop
cdv_calc_final:
    li $t2, 11
    div $t7, $t2
    mfhi $v0
    jr $ra

strcmp:
    move $t0, $a0
    move $t1, $a1
strcmp_l:
    lb $t2, 0($t0)
    lb $t3, 0($t1)
    bne $t2, $t3, strcmp_ne
    beq $t2, $zero, strcmp_eq
    addi $t0, $t0, 1
    addi $t1, $t1, 1
    j strcmp_l
strcmp_eq:
    li $v0, 0
    jr $ra
strcmp_ne:
    li $v0, 1
    jr $ra

strcpy:
    move $t0, $a0
    move $t1, $a1
strcpy_l:
    lb $t2, 0($t1)
    sb $t2, 0($t0)
    beq $t2, $zero, strcpy_f
    addi $t0, $t0, 1
    addi $t1, $t1, 1
    j strcpy_l
strcpy_f:
    jr $ra

fim_programa:
    li $v0, 10
    syscall
    
# ==============================================================================
# BUSCA CLIENTE POR CONTA
# Entrada: $a0 = endereço da string da conta a procurar
# Saída: $v0 = índice do cliente (0 a 49) OU -1 se não achar
# ==============================================================================
busca_cliente:
    addi $sp, $sp, -12
    sw $ra, 8($sp)
    sw $s0, 4($sp)      # Salva $s0 para usar como índice
    sw $s1, 0($sp)      # Salva $s1 para guardar o endereço da conta procurada

    move $s1, $a0       # $s1 = conta que estamos procurando
    li $s0, 0           # $s0 = índice atual (começa em 0)

bc_loop:
    lw $t0, QTD_CLIENTES
    bge $s0, $t0, bc_nao_achou # Se índice >= qtd, percorreu tudo e não achou

    # Calcula endereço da conta do cliente atual [i]
    la $a0, CLIENTES_CONTA
    li $t1, 7
    mul $t2, $s0, $t1   # Offset = i * 7
    addu $a0, $a0, $t2  # Endereço da conta [i]
    move $a1, $s1       # Conta procurada
    jal strcmp          # Compara
    beq $v0, 0, bc_achou # Se strcmp retornou 0, são iguais!

    addi $s0, $s0, 1    # Próximo cliente
    j bc_loop

bc_achou:
    move $v0, $s0       # Retorna o índice encontrado
    j bc_fim

bc_nao_achou:
    li $v0, -1          # Retorna -1 (erro)

bc_fim:
    lw $s1, 0($sp)
    lw $s0, 4($sp)
    lw $ra, 8($sp)
    addi $sp, $sp, 12
    jr $ra
    
# ==============================================================================
# ATOI (ASCII to Integer)
# Entrada: $a0 = endereço da string (ex: "1234")
# Saída: $v0 = valor inteiro (ex: 1234)
# ==============================================================================
atoi:
    li $v0, 0           # Inicializa o resultado com 0
    move $t0, $a0       # $t0 aponta para o início da string
atoi_loop:
    lb $t1, 0($t0)      # Lê o caractere atual
    blt $t1, 48, atoi_fim # Se for menor que '0', terminou
    bgt $t1, 57, atoi_fim # Se for maior que '9', terminou

    sub $t1, $t1, 48    # Converte ASCII para valor numérico (ex: '5' -> 5)
    mul $v0, $v0, 10    # Multiplica o resultado atual por 10 (desloca casa decimal)
    add $v0, $v0, $t1   # Soma o novo dígito

    addi $t0, $t0, 1    # Próximo caractere
    j atoi_loop
atoi_fim:
    jr $ra
    
    # ==============================================================================
# RESGISTRO DE TRANSAÇÃO DE DÉBITO
# Entrada: $a0 = índice do cliente
#  	   $a1 = valor da transação (positivo para depósito, negativo para saque)
# ==============================================================================
registra_transacao:
    # -- Salvando contexto --
    addi $sp, $sp, -12
    sw $t0, 0($sp)
    sw $t1, 4($sp)
    sw $t2, 8($sp)

    move $t0, $a0           # $t0 = índice do cliente
    move $t1, $a1           # $t1 = valor a salvar

    # 1. Verifica quantas transações esse cliente já fez
    la $t2, HISTORICO_DEBITO_QTD
    mul $t3, $t0, 4         # Offset do cliente no vetor de quantidades
    addu $t2, $t2, $t3      # Endereço exato do contador deste cliente
    lw $t4, 0($t2)          # $t4 = Quantidade atual de transações

    # Se já fez 50 transações, por simplificação, não registra mais (ou sobrescreve)
    li $t5, 50
    bge $t4, $t5, rt_fim

    # 2. Calcula onde salvar o novo valor
    # Fórmula: EndereçoBase + (IndiceCliente * 50 * 4) + (IndiceTransacao * 4)
    # 50 * 4 = 200 bytes por cliente
    mul $t5, $t0, 200       # Offset base do cliente
    mul $t6, $t4, 4         # Offset da transação atual
    add $t5, $t5, $t6       # Offset total

    la $t7, HISTORICO_DEBITO_VALOR
    addu $t7, $t7, $t5      # Endereço final onde salvar o valor
    sw $t1, 0($t7)          # Salva o valor da transação!

    # 3. Incrementa a quantidade de transações do cliente
    addi $t4, $t4, 1
    sw $t4, 0($t2)          # Atualiza o contador na memória

rt_fim:
    # -- Restaurando contexto --
    lw $t2, 8($sp)
    lw $t1, 4($sp)
    lw $t0, 0($sp)
    addi $sp, $sp, 12
    jr $ra
    
# ==============================================================================
# REGISTRO DE TRANSAÇÃO DE CRÉDITO
# Entrada: $a0 = índice do cliente, $a1 = valor da transação
# ==============================================================================
registra_credito:
    addi $sp, $sp, -12
    sw $t0, 0($sp)
    sw $t1, 4($sp)
    sw $t2, 8($sp)

    move $t0, $a0
    move $t1, $a1

    # 1. Verifica qtd de transações
    la $t2, HISTORICO_CREDITO_QTD
    mul $t3, $t0, 4
    addu $t2, $t2, $t3
    lw $t4, 0($t2)
    li $t5, 50
    bge $t4, $t5, rc_fim

    # 2. Salva o valor
    mul $t5, $t0, 200       # Offset base do cliente
    mul $t6, $t4, 4         # Offset da transação
    add $t5, $t5, $t6
    la $t7, HISTORICO_CREDITO_VALOR
    addu $t7, $t7, $t5
    sw $t1, 0($t7)

    # 3. Incrementa contador
    addi $t4, $t4, 1
    sw $t4, 0($t2)

rc_fim:
    lw $t2, 8($sp)
    lw $t1, 4($sp)
    lw $t0, 0($sp)
    addi $sp, $sp, 12
    jr $ra
    
# ==============================================================================
# PRINT DINHEIRO
# Entrada: $a0 = valor em centavos (sempre positivo)
# Saída: Imprime "XX,YY\n" no terminal
# ==============================================================================
print_dinheiro:
    addi $sp, $sp, -4
    sw $ra, 0($sp)
    move $t0, $a0           # Salva o valor em $t0

    li $t1, 100
    div $t0, $t1
    mflo $a0                # Parte inteira (Reais)
    li $v0, 1
    syscall

    li $v0, 4
    la $a0, str_virgula     # Vírgula
    syscall

    mfhi $a0                # Resto (Centavos)
    # (Opcional: aqui você poderia adicionar lógica para imprimir um '0' extra
    # se os centavos forem menores que 10, ex: R$ 10,5 virar R$ 10,05)
    li $v0, 1
    syscall

    li $v0, 4
    la $a0, str_newline     # Pula linha no final
    syscall

    lw $ra, 0($sp)
    addi $sp, $sp, 4
    jr $ra
